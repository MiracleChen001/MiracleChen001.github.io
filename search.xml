<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android实现手机摇晃截图]]></title>
    <url>%2F2018%2F09%2F29%2FAndroid%E5%AE%9E%E7%8E%B0%E6%89%8B%E6%9C%BA%E6%91%87%E6%99%83%E6%88%AA%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[今天来介绍个这段时间做的功能，手机摇晃截图。因为这个功能比较常见，所以记录一下以便于之后用到时查阅。 这里说上去是一个功能，其实是有两个需求，即摇晃&amp;截图。 摇晃首先介绍这个摇晃，也就是我们常说的“手机摇一摇”。这个看起来高端，其实实现起来很简单，就是通过SensorManager来检测手机的重力感应，进而判读用户是否在主动的摇晃手机。 核心Service类我们选择建立一个Service，在里面创建我们的SensorManager，并为其注册SensorEventListener，在监听里实现摇晃的判断。具体代码如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.chen.screenshot;import android.app.Service;import android.content.Context;import android.content.Intent;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.os.IBinder;import android.util.Log;public class ShakerWatchService extends Service &#123; private static final String LOG_TAG = ShakerWatchService.class.getName(); private SensorManager mSensorManager; private SensorEventListener mSensorEventListener = new SensorEventListener() &#123; private static final float SENSITIVITY_THRESHOLD = 16; //set the sensitivity of accelerometer private static final int BUFFER = 5; //Buffer used to average the acceleration private static final int SHAKE_DIMENSION = 3; //movement direction private float[] gravity = new float[SHAKE_DIMENSION]; private float average = 0; private int fill = 0; @Override public void onSensorChanged(SensorEvent event) &#123; final float alpha = 0.8F; for (int i = 0; i &lt; SHAKE_DIMENSION; i++) &#123; gravity[i] = alpha * gravity[i] + (1 - alpha) * event.values[i]; &#125; float x = event.values[0] - gravity[0]; float y = event.values[1] - gravity[1]; float z = event.values[2] - gravity[2]; if (fill &lt;= BUFFER) &#123; average += Math.abs(x) + Math.abs(y) + Math.abs(z); fill++; &#125; else &#123; if (average / BUFFER &gt;= SENSITIVITY_THRESHOLD) &#123; handleShakeAction(); &#125; average = 0; fill = 0; &#125; &#125; @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // 第一个参数是Listener，第二个参数是所得传感器类型，第三个参数值获取传感器信息的频率 mSensorManager.registerListener(mSensorEventListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL); return super.onStartCommand(intent, flags, startId); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onDestroy() &#123; mSensorManager.unregisterListener(mSensorEventListener); super.onDestroy(); &#125; private void handleShakeAction() &#123; Log.d(LOG_TAG, &quot;handle shake action&quot;); &#125;&#125; 这样，当service启动时，只要用户摇晃，我们就可以监听到，并触发handleShakeAction()方法。在该方法里写入我们所需要的逻辑即可。 功能调用接着我们在想要使用的时候只需start这个service，想要关闭的时候只要stop这个service就可以了。在Demo里，我在主Activity中使用了一个Switch开关控件来控制摇晃功能的开启与关闭。 布局文件如下。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;Switch android:id=&quot;@+id/switch_shaker&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_margin=&quot;20dp&quot; android:switchPadding=&quot;20dp&quot; android:text=&quot;start shaker&quot; /&gt;&lt;/LinearLayout&gt; 最后是Activity中的调用。 1234567891011121314151617181920212223242526272829303132333435363738package com.chen.screenshot;import android.content.Intent;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.CompoundButton;import android.widget.Switch;public class MainActivity extends AppCompatActivity &#123; private Switch mShakerSwitch; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mShakerSwitch = findViewById(R.id.switch_shaker); mShakerSwitch.setChecked(false); mShakerSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; Intent intent = new Intent(MainActivity.this,ShakerWatchService.class); if (isChecked) &#123; startService(intent); &#125; else &#123; stopService(intent); &#125; &#125; &#125;); &#125; @Override protected void onDestroy() &#123; Intent intent = new Intent(MainActivity.this,ShakerWatchService.class); stopService(intent); super.onDestroy(); &#125;&#125; 至此我们的“手机摇一摇”功能就算是完工了。 截图接下来就是要完成手机截图了。截图的方法有很多种，这里介绍最具代表性的三种。 方法一：View截屏12345public Bitmap capture(Activity activity) &#123; activity.getWindow().getDecorView().setDrawingCacheEnabled(true); Bitmap bmp = activity.getWindow().getDecorView().getDrawingCache(); return bmp;&#125; 这里的思路很清晰，就是获取Activity的Decor View,然后通过View的getDrawingCache（）方法获取View的截屏。这种方法不需额外权限，也不需要Root。但是它不能截取到状态栏，也不能截取SurfaceView及WebView。 方法二：adb截屏这个方法用起来更加简单，只需要在代码中执行一行截屏的adb shell命令即可。麻烦的一点是，需要Root权限。 12// 命令格式： adb shell screencap -p + 文件路径 + 文件名adb shell screencap -p /sdcard/sreenshot1.png 方法三：虚拟桌面截屏鉴于上面两种方法的局限性，我们实际项目中采取了第三种方法，利用Android 5.0开放的录屏API来进行截屏。说到这可能你也发现了，这个方法也是有局限性的，就是只能在Android 5.0以上的手机使用。不过手机更新越来越快，4.X的手机也越来越少，5.0其实也并不算一个很过分的门槛。 该方法的原理是启动屏幕捕捉，使用MediaProjection和ImageReader创建一个虚拟桌面，然后将捕捉的数据传递到虚拟桌面，最后使用ImageReader截取虚拟桌面的一帧画面。 先建立一个AutoScreenShot类，里面写入截屏的核心方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.chen.screenshot;import android.annotation.TargetApi;import android.content.Context;import android.content.Intent;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.PixelFormat;import android.hardware.display.DisplayManager;import android.hardware.display.VirtualDisplay;import android.media.Image;import android.media.ImageReader;import android.media.projection.MediaProjection;import android.media.projection.MediaProjectionManager;import android.os.AsyncTask;import android.os.Build;import android.os.Handler;import android.util.Log;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;public class AutoScreenShot &#123; private static final String LOG_TAG = AutoScreenShotActivity.class.getName(); private static final int CAPTURE_DELAY = 800; private ImageReader mImageReader; private MediaProjection mMediaProjection; private VirtualDisplay mVirtualDisplay; private OnShotListener mOnShotListener; private String mAutoScreenShotPath; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public AutoScreenShot(Context context, int reqCode, Intent data) &#123; mMediaProjection = ((MediaProjectionManager) context.getSystemService(Context.MEDIA_PROJECTION_SERVICE)). getMediaProjection(reqCode, data); mImageReader = ImageReader.newInstance( Resources.getSystem().getDisplayMetrics().widthPixels, Resources.getSystem().getDisplayMetrics().heightPixels, PixelFormat.RGBA_8888, 1); // 内部存储，无需额外申请权限。路径为：Android/data/com.chen.screenshot/files/screenshot/xxxx.png mAutoScreenShotPath = context.getExternalFilesDir(&quot;screenshot&quot;).getAbsoluteFile() + &quot;/&quot; + System.currentTimeMillis() + &quot;.png&quot;; &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) public void startScreenShot(OnShotListener onShotListener) &#123; Log.d(LOG_TAG, &quot;start screen shot&quot;); mOnShotListener = onShotListener; mVirtualDisplay = mMediaProjection.createVirtualDisplay(&quot;screen-mirror&quot;, Resources.getSystem().getDisplayMetrics().widthPixels, Resources.getSystem().getDisplayMetrics().heightPixels, Resources.getSystem().getDisplayMetrics().densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, mImageReader.getSurface(), null, null); // Add this delay for not capture permission dialog shadow new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; Image image = mImageReader.acquireLatestImage(); new SaveImageTask().execute(image); &#125; &#125;, CAPTURE_DELAY); &#125; private class SaveImageTask extends AsyncTask&lt;Image, Void, Bitmap&gt; &#123; @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override protected Bitmap doInBackground(Image... params) &#123; if (params == null || params.length &lt; 1 || params[0] == null) &#123; return null; &#125; Image image = params[0]; int width = image.getWidth(); int height = image.getHeight(); final Image.Plane[] planes = image.getPlanes(); final ByteBuffer buffer = planes[0].getBuffer(); int pixelStride = planes[0].getPixelStride(); int rowStride = planes[0].getRowStride(); int rowPadding = rowStride - pixelStride * width; Bitmap bitmap = Bitmap.createBitmap(width + rowPadding / pixelStride, height, Bitmap.Config.ARGB_8888); bitmap.copyPixelsFromBuffer(buffer); bitmap = Bitmap.createBitmap(bitmap, 0, 0, width, height); image.close(); File fileImage = null; if (bitmap != null) &#123; try &#123; fileImage = new File(mAutoScreenShotPath); if (!fileImage.exists()) &#123; fileImage.createNewFile(); &#125; FileOutputStream out = new FileOutputStream(fileImage); if (out != null) &#123; bitmap.compress(Bitmap.CompressFormat.PNG, 90, out); out.flush(); out.close(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); fileImage = null; &#125; catch (IOException e) &#123; e.printStackTrace(); fileImage = null; &#125; &#125; if (fileImage != null) &#123; return bitmap; &#125; return null; &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) @Override protected void onPostExecute(Bitmap bitmap) &#123; super.onPostExecute(bitmap); if (bitmap != null &amp;&amp; !bitmap.isRecycled()) &#123; bitmap.recycle(); &#125; if (mVirtualDisplay != null) &#123; mVirtualDisplay.release(); &#125; if (mMediaProjection != null) &#123; mMediaProjection.stop(); &#125; if (mImageReader != null) &#123; mImageReader.close(); &#125; if (mOnShotListener != null) &#123; mOnShotListener.onFinish(mAutoScreenShotPath); &#125; &#125; &#125; public interface OnShotListener &#123; void onFinish(String autoScreenShotPath); &#125;&#125; 接着，创建一个透明的Dialog Activity,用来显示截屏权限的dialog。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.chen.screenshot;import android.annotation.TargetApi;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.graphics.drawable.ColorDrawable;import android.media.projection.MediaProjectionManager;import android.os.Build;import android.os.Bundle;import android.support.annotation.Nullable;import android.util.Log;import android.view.Window;import android.widget.Toast;/** * This activity is transparent. * Only use for showing auto screen shot permission dialog. * Auto screen shot need OS version not below Android 5.0 (SDK level 21) */public class AutoScreenShotActivity extends Activity&#123; private static final String LOG_TAG = AutoScreenShotActivity.class.getName(); private static final int REQUEST_MEDIA_PROJECTION = 10000; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.d(LOG_TAG, &quot;AutoScreenShotActivity onCreate()&quot;); requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.TRANSPARENT)); getWindow().setDimAmount(0f); requestScreenShot(); &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void requestScreenShot() &#123; Log.d(LOG_TAG, &quot;requestScreenShot()&quot;); Intent intent = ((MediaProjectionManager) getSystemService(Context.MEDIA_PROJECTION_SERVICE)).createScreenCaptureIntent(); startActivityForResult(intent, REQUEST_MEDIA_PROJECTION); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_MEDIA_PROJECTION) &#123; if(resultCode == RESULT_OK &amp;&amp; data != null) &#123; AutoScreenShot autoScreenShot = new AutoScreenShot(this, resultCode, data); autoScreenShot.startScreenShot(new AutoScreenShot.OnShotListener() &#123; @Override public void onFinish(String autoScreenShotPath) &#123; Log.d(LOG_TAG, &quot;Auto screen shot success&quot;); Toast.makeText(AutoScreenShotActivity.this, &quot;shot success&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; else if (resultCode == RESULT_CANCELED) &#123; Log.d(LOG_TAG, &quot;Not give permission&quot;); Toast.makeText(AutoScreenShotActivity.this, &quot;shot cancel , please give permission.&quot;, Toast.LENGTH_SHORT).show(); &#125; finish(); &#125; &#125;&#125; AndroidManifest里记得设置theme为Theme.Dialog。 1234&lt;activity android:name=&quot;.AutoScreenShotActivity&quot; android:exported=&quot;true&quot; android:theme=&quot;@android:style/Theme.Dialog&quot;/&gt; 总结这样，摇晃手机截屏的基础功能就算是基本完成了。你可以根据项目的特地需求，在这个基础上再做调整修改。]]></content>
      <categories>
        <category>Android 实战</category>
      </categories>
      <tags>
        <tag>摇晃截图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android项目中集成发送邮件功能]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%9C%A8Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[最近项目里有一个需求，要求在项目报错时可以发邮件到指定邮箱。这个功能不算难，但实现起来也有不少的坑。所以记录一下实现过程。 直接发送首先明确一下直接发送的需求，这里要求的是直接在自己的App中点击发送，而不是跳转第三方的邮件App。 环境配置这里发送邮件的实现方式是使用JavaMail for Andorid，需要用到android-mail和android-activation这两个包。在gradle文件中加入以下配置。具体可参考https://javaee.github.io/javamail/#JavaMail_for_Android。 当然， 你也可以下载Jar包集成到项目中，这里是下载地址：https://code.google.com/archive/p/javamail-android/downloads。 Gradle文件配置： 1234dependencies &#123; compile &apos;com.sun.mail:android-mail:1.6.0&apos; compile &apos;com.sun.mail:android-activation:1.6.0&apos;&#125; 这里需要注意的是，Release包下，还需要处理混淆文件，不然会导致Release包下功能失效。 在proguard-rules.pro文件中加入以下代码。 1234567-keep class javax.mail.**&#123;*;&#125;-keep class javax.mail.internet.**&#123;*;&#125;-keep class com.sun.activation.registries.**&#123;*;&#125;-keep class javax.activation.**&#123;*;&#125;-keep class myjava.awt.datatransfer.**&#123;*;&#125;-keep class org.apache.harmony.**&#123;*;&#125;-keep class com.sun.mail.**&#123;*;&#125; 简单实现环境配置好后，我们就可以直接在自己的App中发送邮件了。下面直接分享一下来自官网的Demo，https://javaee.github.io/javamail/docs/api/，亲测可行。 12345678910111213141516Properties props = new Properties();props.put(&quot;mail.smtp.host&quot;, &quot;my-mail-server&quot;);Session session = Session.getInstance(props, null);try &#123; MimeMessage msg = new MimeMessage(session); msg.setFrom(&quot;me@example.com&quot;); msg.setRecipients(Message.RecipientType.TO, &quot;you@example.com&quot;); msg.setSubject(&quot;JavaMail hello world example&quot;); msg.setSentDate(new Date()); msg.setText(&quot;Hello, world!\n&quot;); Transport.send(msg, &quot;me@example.com&quot;, &quot;my-password&quot;);&#125; catch (MessagingException mex) &#123; System.out.println(&quot;send failed, exception: &quot; + mex);&#125; 当然了，这里的参数得改成你自己的，所以做下简单说明。 首先是第2行的props.put，这里可以理解为配置邮箱类别。这里key是不用改的，直接改它的value就可以。举个例子，如果是由126邮箱发出去的，就将value改为smtp.126.com；如果是outlook邮箱发出去的，就将value改为smtp-mail.outlook.com等等。这个值直接搜索某某邮箱的smtp设置就可以得到。 接着是设置Message。顾名思义，msg.setFrom是设置发件箱，msg.setRecipients第二个参数是收件箱，msg.setSubject是邮箱标题，msg.setSentDate是邮件日期，msg.setText是邮件内容。 最后是Transport.send发送，这里需要注意最后一个参数。对于大部分类别的邮箱，这个password不是邮箱的密码，而是邮箱的授权码，具体需要网页登陆自己的邮箱获取。 这样，最简单的邮件发送就实现了。由于是一个网络耗时操作，记得在子线程中调用，就可以成功发送邮件出去了。 项目封装当然，实际项目中不可能像Demo一样简单，需要根据自己的需要做一些封装。 首先是封装邮件的消息体。如果要使用例如outlook这种不支持SSL,只支持TLS的邮箱，一定要加上prop.put(“mail.smtp.starttls.enable”, “true”)这句配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.Properties;public class MailContext &#123; private String mailServerHost; private String mailServerPort; private String fromAddress; private String toAddress; private String userName; private String password; private boolean validate = false; private String subject; private String body; public Properties getProperties() &#123; Properties prop = new Properties(); prop.put(&quot;mail.smtp.host&quot;, mailServerHost); prop.put(&quot;mail.smtp.port&quot;, mailServerPort); prop.put(&quot;mail.smtp.auth&quot;, validate ? &quot;true&quot; : &quot;false&quot;); prop.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;); return prop; &#125; public void setMailServerHost(String mailServerHost) &#123; this.mailServerHost = mailServerHost; &#125; public void setMailServerPort(String mailServerPort) &#123; this.mailServerPort = mailServerPort; &#125; public boolean isValidate() &#123; return validate; &#125; public void setValidate(boolean validate) &#123; this.validate = validate; &#125; public String getFromAddress() &#123; return fromAddress; &#125; public void setFromAddress(String fromAddress) &#123; this.fromAddress = fromAddress; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getToAddress() &#123; return toAddress; &#125; public void setToAddress(String toAddress) &#123; this.toAddress = toAddress; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getSubject() &#123; return subject; &#125; public void setSubject(String subject) &#123; this.subject = subject; &#125; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125;&#125; 接着是对权限的封装，也就是发件箱的账号和密码/授权码。 1234567891011121314151617import javax.mail.Authenticator;import javax.mail.PasswordAuthentication;public class MailAuthenticator extends Authenticator &#123; String userName; String password; public MailAuthenticator(String username, String password) &#123; userName = username; password = password; &#125; // This function will invoke in Authenticator protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(userName, password); &#125;&#125; 然后就是对发送方法的封装了，代码非常清晰简单，相信不用做过多解释就可以看懂。唯一要注意的就是，如果通过MimeMultipart来添加附件，会导致mailMessage.setText这个添加正文的方法无效，需要额外通过MimeBodyPart.setText来重新设置正文。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.IOException;import java.util.Date;import java.util.Properties;import javax.mail.Address;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;public class MailUtils &#123; private static final String LOG_TAG = MailUtils.class.getName(); /** * send mail * * @param mailContext mail context * @param filePath If not have attach file, pass null argument * @return send mail success or not */ public static boolean sendMail(MailContext mailContext, String filePath) &#123; MailAuthenticator authenticator = null; Properties pro = mailContext.getProperties(); if (mailContext.isValidate()) &#123; // If need validate, create authenticator Log.d(LOG_TAG, &quot;create authenticator&quot;); authenticator = new MailAuthenticator(mailContext.getUserName(), mailContext.getPassword()); &#125; Session sendMailSession = Session.getDefaultInstance(pro, authenticator); try &#123; Message mailMessage = new MimeMessage(sendMailSession); Address from = new InternetAddress(mailContext.getFromAddress()); mailMessage.setFrom(from); Address to = new InternetAddress(mailContext.getToAddress()); mailMessage.setRecipient(Message.RecipientType.TO, to); mailMessage.setSubject(mailContext.getSubject()); mailMessage.setSentDate(new Date()); String bodyText = mailContext.getBody(); mailMessage.setText(bodyText); if (!TextUtils.isEmpty(filePath)) &#123; MimeMultipart multipart = new MimeMultipart(); // Set text part MimeBodyPart textPart = new MimeBodyPart(); textPart.setText(bodyText); multipart.addBodyPart(textPart); try &#123; // Set attach part MimeBodyPart attachPart = new MimeBodyPart(); attachPart.attachFile(filePath); multipart.addBodyPart(attachPart); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mailMessage.setContent(multipart); &#125; // Send mail Transport.send(mailMessage); Log.d(LOG_TAG, &quot;sendMail success&quot;); return true; &#125; catch (MessagingException ex) &#123; ex.printStackTrace(); Log.d(LOG_TAG, &quot;sendMail fail &quot; + ex.toString()); return false; &#125; &#125;&#125; 最后就是代码的调用了。这里的FeedbackMessage类就是封装了邮件需要传的属性的一个Bean类,可以根据自己项目的需求自己来写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.google.gson.Gson;import org.json.JSONException;import org.json.JSONObject;public class FeedbackManager &#123; private static final String LOG_TAG = FeedbackManager.class.getName(); private static final String FROM_ADDRESS = &quot;miraclechen@126.com&quot;; private static final String FROM_ADDRESS_PWD = &quot;***********&quot;; private static final String TO_ADDRESS = &quot;1015800546@qq.com&quot;; /** * Send feedback message mail * */ public static void sendFeedback() &#123; String mailContent = getFeedback(); MailContext mailContext = new MailContext(); mailContext.setMailServerHost(&quot;smtp.126.com&quot;); mailContext.setMailServerPort(&quot;25&quot;); mailContext.setValidate(true); mailContext.setUserName(FROM_ADDRESS); mailContext.setPassword(FROM_ADDRESS_PWD); mailContext.setFromAddress(FROM_ADDRESS); mailContext.setSubject(&quot;Feedback Title&quot;); mailContext.setBody(mailContent); mailContext.setToAddress(TO_ADDRESS); MailUtils.sendMail(mailContext, null); Log.d(LOG_TAG, &quot;sendFeedback. mailContent: &quot; + mailContent); &#125; private static String getFeedback() &#123; FeedbackMessage feedbackMessage = new FeedbackMessage(); feedbackMessage.setUserName(BaseUtils.getUserName()); feedbackMessage.setDeviceModel(BaseUtils.getDeviceName()); feedbackMessage.setDeviceId(BaseUtils.getDeviceId()); feedbackMessage.setNetworkState(BaseUtils.isDeviceConnected() ? &quot;Connected&quot; : &quot;DisConnected&quot;); feedbackMessage.setNetworkType(BaseUtils.getNetworkType()); feedbackMessage.setErrorCode(BaseUtils.getErrorCode); feedbackMessage.setErrorMsg(BaseUtils.getErrorMSg()); return new Gson().toJson(feedbackMessage); &#125; 第三方发送在自己程序里发送邮件简单快捷，但由于之前是将发件箱定死了，每天如果发的邮件过多，发件箱可能会认为是在发垃圾邮件，会有将发件箱锁死，导致当天不能再发的风险。 所以，我们监测一下发件状态，在sendMail()方法里catch所有的exception。如果发送失败了，就跳转第三方的邮箱，并获取到发件箱，标题，正文等信息，由用户操作发送。 123456789101112131415public class MailUtils &#123; private static void sendMailViaThirdPartyApp(MailContext mailContext, String filePath, Context context) &#123; Intent intent = new Intent(Intent.ACTION_SEND); intent.setType(&quot;message/rfc822&quot;); intent.putExtra(Intent.EXTRA_EMAIL, new String[]&#123;mailContext.getToAddress()&#125;); intent.putExtra(Intent.EXTRA_SUBJECT, mailContext.getSubject()); intent.putExtra(Intent.EXTRA_TEXT, mailContext.getBody()); if (filePath != null) &#123; intent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(new File(filePath))); &#125; if (intent.resolveActivity(context.getPackageManager()) != null) &#123; context.startActivity(intent); &#125; &#125;&#125; 总结完毕收工！不管是在项目中直接集成邮件发送，还是跳转第三方邮件APP再发送，下次再实现起来都可以一气呵成了。]]></content>
      <categories>
        <category>Android 实战</category>
      </categories>
      <tags>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（五）：建造者模式]]></title>
    <url>%2F2018%2F04%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式干学着难免有些枯燥，相比而言，王者荣耀就显得有意思多了。所以今天我们不谈设计模式，谈农药。 王者荣耀有很多英雄以及装备，不同的英雄还要搭配不同的装备，这个对新手显得不太友好。咱们作为一个老手，今天来帮帮忙。 实现虽然游戏里角色众多，但大致可以分为射手，法师，坦克，战士，辅助这几类。我们为这几大类英雄定制一套通用的出装，来指导新手。 产品类需求有了，根据描述，我们首先得有一个具体的产品类，也就是游戏的英雄角色。 1234567891011121314151617181920212223public class Hero &#123; // 英雄的装备 private List&lt;String&gt; equipments = new ArrayList&lt;String&gt;()； // 英雄的种类 private String type; public Hero(type) &#123; this.type = type; &#125; // 为英雄添加装备 public void add(String equipment) &#123; equipments.add(equipment) &#125; public void show() &#123; Log.d(&quot;Chen&quot;, type + &quot;类英雄通用出装如下：&quot;); for(int i = 0; i &lt; equipments.size(); i++) &#123; Log.d(&quot;Chen&quot;, &quot;第&quot; + i + &quot;件装备出&quot; + equipments.get(i)); &#125; Log.d(&quot;Chen&quot;, &quot;------------------------&quot;); &#125;&#125; 抽象建造者抽象构造者用来规范产品的组建。 12345678910public abstract class Builder &#123; // 设定防御装 protect abstract void buildDefense(); // 设定攻击装 protect abstract void buildAttact(); // 设定移速装 protect abstract void buildSpeed(); // 获得配齐装备的英雄 public abstract Hero getHero();&#125; 具体建造者根据需求，首先实现射手类的具体建造者。具体建造者实现抽象类定义的所有方法，并返回一个组建好的对象。 12345678910111213141516171819202122public class SheShouBuilder extend Build &#123; // 创建产品类的实例 Hero sheShou = new Hero(&quot;射手&quot;); @Override protect void buildDefense()&#123; sheShou.add(&quot;防御装--魔女斗篷&quot;); &#125; @Override protect void buildAttact()&#123; sheShou.add(&quot;攻击装--闪电匕首&quot;); &#125; @Override protect void buildSpeed()&#123; sheShou.add(&quot;移速装--影忍之足&quot;); &#125; @Override protect Hero getHero()&#123; return sheShou; &#125;&#125; 同理，接着实现法师类的具体建造者。 12345678910111213141516171819202122public class FaShiBuilder extend Build &#123; // 创建产品类的实例 Hero fashi = new Hero(&quot;法师&quot;); @Override protect void buildDefense()&#123; fashi.add(&quot;防御装--极寒风暴&quot;); &#125; @Override protect void buildAttact()&#123; fashi.add(&quot;攻击装--痛苦面具&quot;); &#125; @Override protect void buildSpeed()&#123; fashi.add(&quot;移速装--秘法之靴&quot;); &#125; @Override protect Hero getHero()&#123; return fashi; &#125;&#125; 最后时坦克类的具体建造者。 12345678910111213141516171819202122public class TankeBuilder extend Build &#123; // 创建产品类的实例 Hero tanke = new Hero(&quot;坦克&quot;); @Override protect void buildDefense()&#123; tanke.add(&quot;防御装--红莲斗篷&quot;); &#125; @Override protect void buildAttact()&#123; tanke.add(&quot;攻击装--暗影战斧&quot;); &#125; @Override protect void buildSpeed()&#123; tanke.add(&quot;移速装--抵抗之靴&quot;); &#125; @Override protect Hero getHero()&#123; return tanke; &#125;&#125; 导演类导演类负责安排已有模块的组装顺序，并告诉建造者开始建造。 每种英雄角色的侧重点都不同，所以出装顺序很有讲究。 可以看出，这里射手需要输出，所以优先出攻击装；法师需要支援，所以优先出移速装；坦克需要抗伤，所以优先出防御装。 12345678910111213141516171819202122public class Director &#123; public void constructSheShou(Builder builder) &#123; // 射手出装：攻击装-移速装-防御装 builder.buildAttact(); builder.buildSpeed(); builder.buildDefense(); &#125; public void constructFaShi(Builder builder) &#123; // 射手出装：移速装-攻击装-防御装 builder.buildSpeed(); builder.buildAttact(); builder.buildDefense(); &#125; public void constructTanKe(Builder builder) &#123; // 坦克出装：防御装-移速装-攻击装 builder.buildDefense(); builder.buildSpeed(); builder.buildAttact(); &#125;&#125; 客户端调用好了，建造者模式的四大类已经全部完工，接着我们就可以在客户端里进行非常舒服地调用了。 12345678910111213141516Director director = new director();SheShouBuilder sheShouBuilder = new SheShouBuilder();director.constructSheShou(sheShouBuilder);// 射手后羿Hero houYi = sheShouBuilder.getHero();FaShiBuilder faShiBuilder = new FaShiBuilder();director.constructFaShi(faShiBuilder);// 法师妲己Hero daJi = faShiBuilder.getHero();TankeBuilder tankeBuilder = new TankeBuilder();director.constructTanKe(tankeBuilder);// 坦克亚瑟Hero yaSe = tankeBuilder.getHero(); 输出结果如下： 123456789101112131415D/Chen: 射手类英雄通用出装如下：D/Chen: 第1件装备出攻击装--闪电匕首D/Chen: 第2件装备出移速装--影忍之足D/Chen: 第3件装备出防御装--魔女斗篷D/Chen: ------------------------D/Chen: 法师类英雄通用出装如下：D/Chen: 第1件装备出移速装--秘法之靴D/Chen: 第2件装备出攻击装--痛苦面具D/Chen: 第3件装备出防御装--极寒风暴D/Chen: ------------------------D/Chen: 坦克类英雄通用出装如下：D/Chen: 第1件装备出防御装--红莲斗篷D/Chen: 第2件装备出移速装--抵抗之靴D/Chen: 第3件装备出攻击装--暗影战斧D/Chen: ------------------------ 总结真的只是王者荣耀的总结~不管你信不信，反正我信了。 优点 封装性：使用建造者模式可以使客户端不必知道产品内部组成的细节。 易扩展：建造者是独立的，对系统的扩展非常有利。 规避风险：建造的过程不会对其他模块产生影响。 使用场景 需要生产的产品对象有复杂的内部结构，这些产品对象具备共性。 需要隔离复杂对象的创建和使用。 产品类中不同的调用顺序会产生不同的效能。 建造者模式（也叫做生成器模式）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（四）：模板方法模式]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[还记得在前面工厂方法里开的水果店么？现在咱们业务扩展了，开始兼售鲜榨果汁。 我们已经有了那么多的水果，接下来做鲜榨果汁就简单多了。就地取材，处理新鲜水果，然后放入榨汁机，榨完倒入杯子，最后打包就行了。 下面我们就实现这个听起来就很靠谱很赚钱的业务。 实现首先，定义鲜榨果汁的超类，在里面按照我们上面的步骤，写出产出鲜榨果汁的算法。 12345678910111213141516171819202122public abstract class Juice &#123; protected abstract void prepare(); protected abstract void putMachine(); private void pourCup() &#123; Log.d(&quot;Chen&quot;, &quot;倒入定制塑料杯...&quot;); &#125; private void pack() &#123; Log.d(&quot;Chen&quot;, &quot;杯子封口打包...&quot;); &#125; public void produce() &#123; Log.d(&quot;Chen&quot;, &quot;鲜榨果汁现场制作开始！&quot;); prepare(); putMachine(); pourCup(); pack(); Log.d(&quot;Chen&quot;, &quot;鲜榨果汁现场制作完成！&quot;); &#125;&#125; 接着，实现具体的果汁。 苹果汁： 1234567891011public class AppleJuice extends Juice &#123; @Override protected void prepare() &#123; Log.d(&quot;Chen&quot;, &quot;取苹果洗净，削皮...&quot;); &#125; @Override protected void putMachine() &#123; Log.d(&quot;Chen&quot;, &quot;把苹果放入榨汁机...&quot;); &#125;&#125; 橙汁： 1234567891011public class OrangeJuice extends Juice &#123; @Override protected void prepare() &#123; Log.d(&quot;Chen&quot;, &quot;取橙子洗净，剥皮...&quot;); &#125; @Override protected void putMachine() &#123; Log.d(&quot;Chen&quot;, &quot;把橙子放入榨汁机...&quot;); &#125;&#125; 最后我们来调用得到这些果汁。 1234AppleJuice appleJuice = new AppleJuice();appleJuice.produce();OrangeJuice orangeJuice = new OrangeJuice();orangeJuice.produce(); 观察我们得到的Log信息： 123456789101112D/Chen: 鲜榨果汁现场制作开始！D/Chen: 取苹果洗净，削皮...D/Chen: 把苹果放入榨汁机...D/Chen: 倒入定制塑料杯...D/Chen: 杯子封口打包...D/Chen: 鲜榨果汁现场制作完成！D/Chen: 鲜榨果汁现场制作开始！D/Chen: 取橙子洗净，剥皮...D/Chen: 把橙子放入榨汁机...D/Chen: 倒入定制塑料杯...D/Chen: 杯子封口打包...D/Chen: 鲜榨果汁现场制作完成！ 扩展模板方法模式还可以设置钩子方法，用来约束模板方法的行为。 比如刚刚的苹果汁和橙汁都是原味的，苹果汁可能没问题，但橙汁有些客人就会觉得有点酸，需要加点糖。 12345678910111213141516171819202122232425262728293031323334public abstract class Juice &#123; protected abstract void prepare(); protected abstract void putMachine(); private void pourCup() &#123; Log.d(&quot;Chen&quot;, &quot;倒入定制塑料杯...&quot;); &#125; protected void addSugar() &#123; Log.d(&quot;Chen&quot;, &quot;加入独家秘制白糖...&quot;); &#125; private void pack() &#123; Log.d(&quot;Chen&quot;, &quot;杯子封口打包...&quot;); &#125; public void produce() &#123; Log.d(&quot;Chen&quot;, &quot;鲜榨果汁现场制作开始！&quot;); prepare(); putMachine(); pourCup(); if(needAddSugar()) &#123; addSugar(); &#125; pack(); Log.d(&quot;Chen&quot;, &quot;鲜榨果汁现场制作完成！&quot;); &#125; //钩子方法，默认不用加糖 protect boolean needAddSugar() &#123; return false; &#125;&#125; 扩展后的橙汁类： 1234567891011121314151617181920212223public class OrangeJuice extends Juice &#123; private boolean needAddSugar = false; @Override protected void prepare() &#123; Log.d(&quot;Chen&quot;, &quot;取橙子洗净，剥皮...&quot;); &#125; @Override protected void putMachine() &#123; Log.d(&quot;Chen&quot;, &quot;把橙子放入榨汁机...&quot;); &#125; //是否要加糖，由客人决定 public void setNeedAddSugar(boolean needAddSugar) &#123; this.needAddSugar = needAddSugar; &#125; @Override protected void needAddSugar() &#123; return needAddSugar; &#125;&#125; 最后调用： 123OrangeJuice orangeJuice = new OrangeJuice();orangeJuice.setNeedAddSugar(true);orangeJuice.produce(); Log信息： 1234567D/Chen: 鲜榨果汁现场制作开始！D/Chen: 取橙子洗净，剥皮...D/Chen: 把橙子放入榨汁机...D/Chen: 倒入定制塑料杯...D/Chen: 加入独家秘制白糖...D/Chen: 杯子封口打包...D/Chen: 鲜榨果汁现场制作完成！ 总结模板方法非常简单，仅仅使用了继承机制，用四个字概况就是：流程封装。但它是一个应用非常广泛的模式。 基本结构其中，上面最主要的Juice类叫做抽象模板，它里面的方法分为三类 基本方法： 也叫基本操作，在父类或者子类里实现，并在模板方法里被调用。 模板方法： 是一个框架，实现对基本方法的调用，完成固定的逻辑。为了防止恶意的操作，可以在该方法上加上final关键字，不允许子类重写。 钩子方法：用来约束模板方法的行为。 AppleJuice和OrangeJuice类叫做具体模板，实现抽象模板中所定义的基本方法。 应用场景 多个子类有公共的方法，并且逻辑相同时。 重要复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各子类实现。 重构时，把相同代码抽取到父类中，然后通过钩子方法约束其行为。 优点 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现，符合开闭原则。 缺点降低了代码的可读性。 模板方法模式： 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（三）：抽象工厂模式]]></title>
    <url>%2F2018%2F04%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[接着上一文的工厂方法模式，咱们的水果店继续蓬勃发展，水果种类越来越多。 比如，之前卖的苹果，现在会有红富士、黄元帅、青苹果多种种类；桃子会有油桃，水蜜桃，黄桃；梨子也会有砂糖梨，香梨，雪梨。 这时候，我们就需要抽象工厂来帮我们解决这个需求。 实现以苹果为例，它这里是一个抽象产品类。 123public abstract class IApple &#123; public abstract void description();&#125; 接着是具体产品类，显然这里是具体的各种水果。 1234567891011121314151617181920public class RedApple extends IApple &#123; @Override public void description() &#123; Log.d(&quot;Chen&quot;, &quot;红富士，12块一斤&quot;); &#125;&#125;public class YellowApple extends IApple &#123; @Override public void description() &#123; Log.d(&quot;Chen&quot;, &quot;黄元帅，10块一斤&quot;); &#125;&#125;public class GreenApple extends IApple &#123; @Override public void description() &#123; Log.d(&quot;Chen&quot;, &quot;青苹果，8块一斤&quot;); &#125;&#125; 可以明显地看出，工厂方法模式是生产单个同类型的不同产品，而抽象工厂模式生产的是多个不同类型的不同产品，所以必须将共同点抽象出来。 抽象工厂类：我们的水果店。 12345public abstract class FoodFactory &#123; public abstract IApple createApple(int type); public abstract IPeach createPeach(int type); public abstract IPear createPear(int type);&#125; 具体工厂类：以具体的第一水果分店为例。 123456789101112131415161718192021public class FruitFactoryOne extends FruitFactory&#123; public static final int TYPE_RED = 1; // 红富士 public static final int TYPE_YELLOW = 2; // 黄元帅 public static final int TYPE_GREEN = 3; // 青苹果 @Override public IApple creatApple(int type) &#123; if (type == TYPE_RED) &#123; return new RedApple(); &#125; else if (type == TYPE_YELLOW) &#123; return new YellowApple(); &#125; else if (type == TYPE_GREEN) &#123; return new GreenApple(); &#125; else &#123; throw new IllegalArgumentException(&quot;Wrong type.&quot;); &#125; &#125; // 创建具体桃子，梨子的方法与苹果类似 ...&#125; 最后是调用： 123FruitFactory factory = new FruitFactoryOne();IApple apple = factory.creatApple(FruitFactoryOne.TYPE_YELLOW);apple.description(); 输出结果： 1D/Chen: 黄元帅，10块一斤 总结老规矩，讲完了基本的结构，作一下最后总结。 抽象工厂与工厂方法的差别普通工厂产出是一个产品，抽象工厂产出是一个抽象。区别在于，若添加一个新的产品，前者是修改工厂，后者是创建新工厂。 所以在抽象工厂模式中，增加一个产品族（比如再加一个橘柑种类）很容易，而增加一个产品等级结构（比如在苹果类里再加一个嘎啦果的子类）却很难，工厂模式则反之。 也就是说，在抽象工厂模式中，增加一个具体的工厂很容易。但是你想在工厂中多生产一种产品，就需要修改很多个类，会违背开闭原则，这种情况下应该使用工厂模式。 优点 面向接口编程，使创建对象从具体的产品实现中解耦。 在切换产品类时更加灵活。 缺点 类文件爆炸。 不容易扩展新的具体产品类。 抽象工厂模式：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（二）：工厂方法模式]]></title>
    <url>%2F2018%2F04%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[俗话说，不会卖水果的程序员不是好的程序员。今天，我们就来卖水果。 简单工厂因为水果店里的水果种类众多，我们这里选择使用简单工厂来实现。 需要说明的是，简单工厂其实并不能算是23个设计模式中的一个，它更像是一种编程习惯。 普通简单工厂首先，我们需要创建出抽象产品类，这里当然就是水果咯。 123public abstract class IFruit &#123; public abstract void description();&#125; 接着是具体产品类，显然这里是具体的各种水果。 1234567891011121314151617181920public class Apple extends Ifruit &#123; @Override public void description() &#123; Log.d(&quot;Chen&quot;, &quot;苹果，10块一斤&quot;); &#125;&#125;public class Peach extends Ifruit &#123; @Override public void description() &#123; Log.d(&quot;Chen&quot;, &quot;桃子，12块一斤&quot;); &#125;&#125;public class Pear extends Ifruit &#123; @Override public void description() &#123; Log.d(&quot;Chen&quot;, &quot;梨子，8块一斤&quot;); &#125;&#125; 然后就是我们的主角，简单工厂类。 1234567891011121314151617public class FruitFactory &#123; public static final int TYPE_APPLE = 1; // 苹果 public static final int TYPE_PEACH = 2; // 桃子 public static final int TYPE_PEAR = 3; // 梨子 public IFruit creatFruit(int type) &#123; if (type == TYPE_APPLE) &#123; return new Apple(); &#125; else if (type == TYPE_PEACH) &#123; return new Peach(); &#125; else if (type == TYPE_PEAR) &#123; return new Pear(); &#125; else &#123; throw new IllegalArgumentException(&quot;Wrong type.&quot;); &#125; &#125;&#125; 最后在我们的水果店就可以给顾客提供各种水果啦。正式开张，鼓掌！ 这不，已经有顾客来买苹果了。 123FruitFactory factory = new FruitFactory();IFruit fruit = factory.creatFruit(FruitFactory.TYPE_APPLE);fruit.description(); 输出结果： 1D/Chen: 苹果，10块一斤 静态简单工厂一般在使用的时候，我们会将工厂类里的方法直接定义成静态的，这样就不用再new一个工厂对象出来了。 1234567891011121314151617public class FruitFactory &#123; public static final int TYPE_APPLE = 1; // 苹果 public static final int TYPE_PEACH = 2; // 桃子 public static final int TYPE_PEAR = 3; // 梨子 public static IFruit creatFruit(int type) &#123; if (type == TYPE_APPLE) &#123; return new Apple(); &#125; else if (type == TYPE_PEACH) &#123; return new Peach(); &#125; else if (type == TYPE_PEAR) &#123; return new Pear(); &#125; else &#123; throw new IllegalArgumentException(&quot;Wrong type.&quot;); &#125; &#125;&#125; 调用时： 12IFruit fruit = FruitFactory.creatFruit(FruitFactory.TYPE_APPLE);fruit.description(); 所以我们也把这种写法称为静态工厂。 多方法简单工厂细心的小伙伴可能已经发现了，上面的方法有一个缺点，如果creat()时传递的参数不正确，就会得不到想要的产品。 所以又出现了接下来多方法简单工厂这种写法。它为不同的产品，提供了不同的方法，这样容错率比较高。 12345678910111213public class FruitFactory &#123; public static IFruit creatApple() &#123; return new Apple(); &#125; public static IFruit creatPeach() &#123; return new Peach(); &#125; public static IFruit creatPear() &#123; return new Pear(); &#125;&#125; 依然还是以买苹果为例： 12IFruit fruit = FruitFactory.creatApple();fruit.description(); 反射简单工厂我们也可以通过反射，在工厂类里实现产品的创建。 1234567891011public class FruitFactory &#123; public static &lt;T extends IFruit&gt; T createFruit(Class&lt;T&gt; clz) &#123; T result = null; try &#123; result = (T) Class.forName(clz.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; 调用时： 12IFruit fruit = FruitFactory.createFruit(Apple.class);fruit.description(); 工厂模式水果店生意越做越大，慢慢有了一个又一个的分店出现。这时候，就需要工厂模式出来帮忙了。 首先，将上面工厂类进行抽象，得到一个抽象工厂类。 123public abstract class FruitFactory &#123; public abstract IFruit creatFruit(int type);&#125; 接着是我们的分店，每个分店里卖的水果可能多种多样，各不相同。这里以第一分店为例。 123456789101112131415161718public class FruitFactoryOne extends FruitFactory&#123; public static final int TYPE_APPLE = 1; // 苹果 public static final int TYPE_PEACH = 2; // 桃子 public static final int TYPE_PEAR = 3; // 梨子 @Override public IFruit creatFruit(int type) &#123; if (type == TYPE_APPLE) &#123; return new Apple(); &#125; else if (type == TYPE_PEACH) &#123; return new Peach(); &#125; else if (type == TYPE_PEAR) &#123; return new Pear(); &#125; else &#123; throw new IllegalArgumentException(&quot;Wrong type.&quot;); &#125; &#125;&#125; 123FruitFactory factory = new FruitFactoryOne();IFruit fruit = factory.creatFruit(FruitFactoryOne.TYPE_APPLE);fruit.description(); 接着的第二分店、第三分店等等，里面的水果种类可能不一样，会有桔子、香蕉，但写法结构都是一样的。 可以看出工厂模式的特点：不仅仅产品要抽象，工厂也需要抽象，它使得一个产品类的实例化延迟到具体的工厂子类。 这样可以更好的符合开闭原则。当需求变化时（比如再开一家分店）,只需要增删想应的类，而不需要修改已有的方法。 总结工厂模式的使用方法到此就介绍了差不多了，我们做一下最后的总结。 简单工厂和工厂方法的差别简单工厂把所有事情，在一个地方都处理完了。然而工厂方法却是创立了一个框架，让子类决定要如何去做。 在刚刚的例子中可以看出，最突出的体现就是建立了抽象的工厂类。 这样，工厂方法会具有简单工厂所不具有的弹性，更能应对未来的扩展。 优点 封装性良好，代码结构清晰。 扩展性非常优秀。 屏蔽产品类，是典型的解耦框架。 实践工厂方法模式在项目中使用非常频繁，但这并不代表每个人都可以用得很好。平时一定要多思考工厂方法如何使用，才能够做到熟练掌握。 而且工厂方法模式还可以与其他模式（比如单例模式、模板方法、原型模式等）混合使用，变化出无穷的优秀设计。 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列（一）：单例模式]]></title>
    <url>%2F2018%2F04%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[谈到设计模式，相信很多人脑子里蹦出的第一个就是单例模式。好的，如你所愿，今天设计模式的第一篇，我们从单例模式开始谈起。 使用场景在一个系统中，要求一个类有且一个对象，如果出现多个对象会带来不必要的麻烦，可以采用单例模式。具体的场景有： 要求生成唯一序列号的环境。 在整个项目中需要一个共享访问点或共享数据，如计数器。 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源。 需要定义大量的静态常亮和静态方法，如工具类。 一 饿汉式首先是最简单的实现方式，饿汉式。 为了保证类只能创建出一个对象，我们首先需要将构造方法设置为私有，无法为外界所调用。接着在类加载（应用启动）时就初始化一个对象出来。最后提供一个静态公共方法，获取这个对象。 123456789public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 二 懒汉式基础版上面的饿汉式简单粗暴，但有一个缺点，就是在类加载时就需要初始化这个对象。如果单例占用内存很少，初始化速度很快，这样使用没什么问题。但是如果单例占用的内存比较大，而应用对启动速度又有要求，我们就需要对上面的方式加以优化了。 123456789101112public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(null == instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉式顾名思义，只有在需要的时候，才进行单例的初始化操作。首次调用会创建出新的对象，再次调用会直接返回之前已创建出来的对象。 同步锁乍一看上去，上面基础版的写法完美解决了问题。但细看看，这样写在多线程时，可能会带来新的问题。如果现在有两个线程同时在执行getInstance()方法，线程A刚进行了判断，还没来得及创建对象，这时线程B也执行到了判断，会发现instance仍然还是为null。这个时候所谓的单例就名不符实了，因为创建出了两个对象。而饿汉式不会出现这个问题，是因为JVM只会加载一次。 熟悉点并发知识会很容易解决这个问题。既然getInstance()是线程不安全的，那么我们给它加上一个同步锁就好了。 123456789101112public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(null == instance)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重校验锁上面的同步锁写法在逻辑上已经没什么漏洞了，但仍然有优化的空间。因为这样写，每次调用getInstance（）方法时都会受到同步锁synchronized的影响。而事实上，这个同步锁是对性能有消耗的。如果instance已经实例化了，我们就不需要再获取同步锁了，从而提高性能。 首先把synchronized从方法声明中移到方法体中，这样的效果与上面的完全一致。 1234567891011121314public class Singleton&#123; private static Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125;&#125; 接着在synchronized外面再加一层判断，只有在没有初始化时，才会获取同步锁。 1234567891011121314151617public class Singleton &#123; private static Singleton instance = null; private Singleton()&#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 三 静态内部类因为JVM在进行类加载的时候会保证数据同步的，所以我们可以采用静态内部类来保证线程安全。 1234567891011public class Singleton&#123; private static class SingletonHolder&#123; public static Singleton instance = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125; 这样写十分简洁，而且同时解决了线程安全和延迟加载的问题。 四 枚举《Effective Java》中推荐了一种更简洁的方式来实现单例，它就是枚举。 创建枚举实例是线程安全的，所以不需要额外做并发处理。 1234567public enum Singleton&#123; INSTANCE; public void functionA()&#123; // 功能方法 &#125; &#125; 调用方法时可以直接这么用。 1Singleton.INSTANCE.functionA(); 要注意的是，在Android中并不十分推荐使用这种方法。因为它虽然简洁，但枚举内存占用是静态变量的两倍以上，所以尽可能地去避免使用枚举。 总结好了，设计模式的第一篇，单例模式差不多就讲到这里了。最后再归纳一下单例模式的优缺点。 优点 单例模式在内存中只有一个实例，减少了内存开支。当一个对象需要频繁地创建、销毁，或者对象的产生需要比较多的资源时，单例的优势就非常明显。 单例模式可以避免对资源的多重占用。比如一个写文件操作，由于只有一个实例，可以避免对资源文件的同时操作。 单例模式可以在系统设置全局的访问点，优化和共享资源访问。比如负责所有数据表的映射处理的单例类。 缺点 单例模式一般没有接口（因为它要求自行实例化，接口对它没有意义），所以扩展很困难。 单例模式如果持有Context，很容易引发内存泄漏。要注意传递给单例对象的Context最好是Application Context。 单例模式与单一职责原则有冲突。 单例模式：确保一个类仅有一个实例，而且自行实例化并向整个系统提供这个实例。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式系列开篇：六大原则]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E5%BC%80%E7%AF%87%EF%BC%9A%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[设计模式说白了就是一套由前人们总结出来的一套可以反复使用的经验理论。它可以提高代码的可重用性，增强系统的可维护性，加强代码的可读性。 在这套经验理论里，前人们提出了以下六个原则，需要我们在设计时来遵循。 单一职责原则 Single Responsibility Principle (SRP)：就一个类而言，应该仅有一个引起它变化的原因。 一个类应该是一组相关性很高的函数、数据的封装。两个完全不一样的功能就不应该放在一个类中。 实际上，如何去划分一个类、一个函数的职责，每个人都有自己的看法。这需要根据个人经验和具体的业务逻辑而定。所以这个原则从概念上来看最简单，实施起来却是最难。 所幸的是，它也有一些基本的指导原则，比如：一个类应该是一组相关性很高的函数、数据的封装。两个完全不一样的功能就不应该放在一个类中。 单一职责原则具有以下优点： 类的复杂度降低，提高了可读性。 降低变更引起的风险，容易维护。 里氏替换原则 Liskov Substitution Principle (LSP)：所有引用父类的地方必须能透明地使用其子类的对象。 这里还存在另外一个定义，相对拗口一点，需要多理解几遍。如果对每一个类型为S的对象O1，都存在有类型为T的对象O2，使得在以T定义的所有程序P里,所有的对象O2都可以用O1替换，程序P的行为没有发生变化，那么类型S为类型T的子类。 简单来说就是，只要父类能出现的地方，子类就可以出现。而且替换为子类也不会产生任何错误或者异常。但是反过来就不行了，有子类出现的地方，父类未必就能适应。 它的优点是： 提高代码的重用性，子类拥有父类的方法和属性。 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性。 它的缺点是： 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性。 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。 依赖倒转原则定义 Dependency Inversion Principle (DIP)：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖于细节；细节应当依赖于抽象。 在Java中，细节就是指接口或抽象类，细节就是指实现类。所以这个定义在Java中的表现就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 接口或抽象类不依赖于实现类。 实现类依赖接口或抽象类。 更简单的定义就是针对接口编程，而不是针对实现编程。 依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。 运用我们用一个司机开汽车的例子来深入了解下依赖倒转原则。 首先有一个奔驰车类。 12345public class Benz &#123; public void run ()&#123; Log.d(&quot;Chen&quot;, &quot;奔驰车在飞奔...&quot;); &#125;&#125; 接着有一个司机类，司机可以驾驶奔驰车。 12345public class Driver &#123; public void drive (Benz benz) &#123; benz.run(); &#125;&#125; 这样，我们就可以在测试方法中，完成司机开奔驰车了。 123Driver xiaoWang = new Driver();Benz benz = new Benz();xiaoWang.driver(benz); 这个程序看起来很完美，直到有一天，出现了一个宝马汽车类。 12345public class Bmw &#123; public void run ()&#123; Log.d(&quot;Chen&quot;, &quot;宝马车在飞奔...&quot;); &#125;&#125; 尴尬的事来了，小王作为一个可以开奔驰的司机，居然没办法驾驶宝马车。这显然是不合理的。这就是实现类之间发生了直接的依赖关系带来的，它会加重类间的耦合性，降低代码的可维护性。 所以我们这里需要设计出司机和汽车的接口，通过它们产生依赖关系。 1234567public interface Icar &#123; public void run();&#125;public interface IDriver &#123; public void driver(Icar car);&#125; 接着司机类实现司机接口，奔驰、宝马实现汽车接口。 1234567891011121314151617public class Driver implements IDriver &#123; public void driver(Icar car) &#123; car.run(); &#125;&#125;public class Benz implements ICar&#123; public void run ()&#123; Log.d(&quot;Chen&quot;, &quot;奔驰车在飞奔...&quot;); &#125;&#125;public class Bmw implements ICar&#123; public void run ()&#123; Log.d(&quot;Chen&quot;, &quot;宝马车在飞奔...&quot;); &#125;&#125; 现在不管奔驰、宝马，还是其他的汽车，小王都可以驾驶了。 12345IDriver xiaoWang = new Driver();Icar benz = new Benz();Icar bmw = new Bmw();xiaoWang.driver(benz);xiaoWang.driver(bmw); 接口隔离原则 Interface Segregation Principle (ISP)：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。 我们需要将非常庞大臃肿的接口拆分成更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。 也就是说，要让客户端依赖的接口尽可能少。 迪米特法则 Law of Demeter (LoD)：也称为最少知识原则，一个对象应该对其他对象有最少的了解。 通俗地讲就是，一个类应该对自己需要耦合或调用的类知道的最少。类的内部如何实现与调用者或者依赖者没关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不用管。 LoD要求我们只与直接的朋友通信，不跟陌生人说话。朋友类的定义是，出现在成员变量、方法的输入输出参数中的类。出现在方法体内部的类不属于朋友类。 LoD的核心观念就是类间解耦，只有弱耦合了以后，类的复用率才可以提高。不过它也会带来系统的复杂性的提高，为维护带来难度。所以采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。 开闭原则 Open Closed Principle (OCP)：软件中的对象（类、模块、函数等）应当对扩展是开放的，但对修改是封闭的。 程序一旦开发完成，程序中的一个类只应该因错误而被修改，新的或者改变的特性应该通过新建不同的类实现。新建的类可以通过继承的方式重用原类的代码。 开闭原则是一个终级目标，任何人也无法百分之百做到。但以它为指引，朝着这个方向努力，可以非常显著地改变一个系统的架构，真正做到拥抱变化。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>六大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程必知概念]]></title>
    <url>%2F2018%2F03%2F27%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BF%85%E7%9F%A5%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[不管前台还是后台开发，总避免不了多线程的运用。是时候，好好梳理一下多线程的基本概念了。 线程的概念 进程一般指一个执行单元。 进程在PC和移动端通常指一个程序和一个应用。 在Android中，我们也可以通过在AndroidMenifest中指定四大组件的android:process属性，为应用开启多个进程。 线程是操作系统调度的最小单元，是进程的执行单元。 进程和线程的关系如下。 进程与线程是一对多的关系。一个进程可以拥有一个或多个线程，一个线程只有一个父进程。 线程之间共享父进程的共享资源，相互之间协同完成父进程所要完成的任务。 一个线程可以创建和撤销另一个线程，同一个进程的多个线程之间可以并发执行。 线程的创建继承Thread类创建线程1234567891011121314public class MyThread extends Thread &#123; // 新建一个类继承Thread类，并重写run()方法 @Override public void run() &#123; System.out.println(&quot;run in my thread&quot;); &#125; public static void main(String[] args) &#123; // 创建新建Thread类的实例 MyThread myThread = new MyThread(); // 调用实例的start()方法启动线程 myThread.start(); &#125;&#125; 实际开发中，可以用匿名内部类快速开启一个线程。 12345new Thread()&#123; public void run()&#123; System.out.println(&quot;run in my thread&quot;); &#125;&#125;.start(); 实现Runnable接口创建线程12345678910111213141516public class MyRunnable implements Runnable &#123; // 新建一个类实现Runnable接口，并重写run()方法 @Override public void run() &#123; System.out.println(&quot;run in my thread&quot;); &#125; public static void main(String[] args) &#123; // 创建新建类的实例 MyRunnable myRunnable = new MyRunnable(); // 通过runnable实例，新建Thread类实例 Thread thread = new Thread(myRunnable); // 调用新建Thread类实例的start()方法启动线程 thread.start(); &#125;&#125; 同样，我们可以用匿名内部类快速开启一个线程。 12345new Thread(new Runnable() &#123; public void run()&#123; System.out.println(&quot;run in my thread&quot;); &#125;&#125;).start(); 线程的生命周期五大状态当一个线程开启后，它会经过新建，就绪，运行，阻塞和死亡这五种状态。 新建状态：线程刚被创建出来，此时线程并无任何动态特征。 就绪状态：线程可以运行。 运行状态：线程正在运行。 阻塞状态：线程处被暂停。 死亡状态: 线程被停止。 线程优先级设置和获取线程优先级的方法。 12public final void setPriority(int newPriority)public final int getPriority() 线程优先级的取值范围为1到10，也可以用静态变量设置。 123public static final int MIN_PRIORITY = 1;public static final int NORM_PRIORITY = 5;public static final int MAX_PRIORITY = 10; 线程默认的优先级是父线程的优先级。Java主线程的默认优先级是NORM_PRIORITY = 5。 后台线程设置后台线程以及判断线程是否为后台线程的方法。 12public final void setDaemon(boolean on)public final boolean isDaemon() start() 和 run()线程新建完之后，调用start()方法，使线程处于就绪状态。 当就绪状态的线程获得CPU资源后，会自动执行run()方法，使线程处于运行状态。 sleep()线程在运行状态时，调用sleep()方法，使线程处于阻塞状态。 1public static native void sleep(long millis) throws InterruptedException 这里Java中的native关键字，说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。 接着我们在Activity中加入一个按钮，定义其点击方法sleep()。 123456789101112131415161718192021public class ThreadActivity extends Activity &#123; public void sleep(View view) &#123; SleepThread sleepThread = new SleepThread(); sleepThread.start(); &#125; class SleepThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; Log.d(&quot;Chen&quot;, &quot;Thread Sleep...&quot;); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 每隔一秒会输出”Thread Sleep…”，线程生命周期变化如下。 yield()1public static native void yield() 这个方法通常被翻译为线程让步。顾名思义，当一个线程正在运行的时候，做出了让步，回到就绪状态，重新回到与其他线程再重新分配CPU资源。 123456789101112131415161718192021222324public class ThreadActivity extends Activity &#123; public void yield(View view) &#123; YieldThread yieldThread1 = new YieldThread(&quot;线程A&quot;); YieldThread yieldThread2 = new YieldThread(&quot;线程B&quot;); yieldThread1.start(); yieldThread2.start(); &#125; class YieldThread extends Thread &#123; public YieldThread(String name)&#123; super(name); &#125; @Override public void run() &#123; super.run(); for (int i = 0; i &lt; 20; i++) &#123; Log.d(&quot;Chen&quot;, getName() + &quot;: --&gt; &quot; + i); if (i == 5) &#123; Thread.yield(); &#125; &#125; &#125; &#125;&#125; 需要注意的是，这里的打印结果每次都不一定相同。因为线程调用过yield()后，线程调度器可能会启动其他线程，也可能继续启动该线程。 join()12public final void join() throws InterruptedExceptionpublic final synchronized void join(long millis) throws InterruptedException 这个方法需要有两个线程。比如在线程A执行体中，线程B调用join()方法。这时候线程A就会被阻塞，必须等线程B执行完或者join()的时间到了，线程A才会继续执行。 123456789101112131415161718192021222324252627282930313233343536public class ThreadActivity extends Activity &#123; public void join(View view) &#123; new Thread(&quot;线程A&quot;) &#123; @Override public void run() &#123; super.run(); try &#123; JoinThread joinThread = new JoinThread(&quot;线程B&quot;); for (int i = 0; i &lt; 10; i++) &#123; if (i == 4) &#123; joinThread.start(); joinThread.join(); &#125; Log.d(&quot;Chen&quot;, getName() + &quot;: --&gt; &quot; + i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; class JoinThread extends Thread &#123; public JoinThread(String name) &#123; super(name); &#125; @Override public void run() &#123; super.run(); for (int i = 0; i &lt; 10; i++) &#123; Log.d(&quot;Chen&quot;, getName() + &quot;: --&gt; &quot; + i); &#125; &#125; &#125;&#125; 运行结果如下。可以看出，如果没有设定join的时长，线程A会先让线程B一直执行完毕后，才会继续执行。 123456789101112131415161718192003-31 06:29:45.976 999-1130/com.chen.study E/Chen: 线程A: --&gt; 003-31 06:29:45.979 999-1130/com.chen.study E/Chen: 线程A: --&gt; 103-31 06:29:45.979 999-1130/com.chen.study E/Chen: 线程A: --&gt; 203-31 06:29:45.979 999-1130/com.chen.study E/Chen: 线程A: --&gt; 303-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 003-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 103-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 203-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 303-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 403-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 503-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 603-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 703-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 803-31 06:29:45.985 999-1131/com.chen.study E/Chen: 线程B: --&gt; 903-31 06:29:45.986 999-1130/com.chen.study E/Chen: 线程A: --&gt; 403-31 06:29:45.986 999-1130/com.chen.study E/Chen: 线程A: --&gt; 503-31 06:29:45.986 999-1130/com.chen.study E/Chen: 线程A: --&gt; 603-31 06:29:45.986 999-1130/com.chen.study E/Chen: 线程A: --&gt; 703-31 06:29:45.986 999-1130/com.chen.study E/Chen: 线程A: --&gt; 803-31 06:29:45.986 999-1130/com.chen.study E/Chen: 线程A: --&gt; 9 多线程常见知识了解完线程的基本概念，接下来我们需要知道多线程里常见的一些知识。 同步和异步 同步：调用者必须要等到调用的方法返回后才会继续后续的行为。异步：调用者调用后，不需等调用方法返回就可以继续后续的行为。 通常单线程环境下都是同步行为，我们可以通过开启多条线程实现异步操作。 并发和并行 并发：多个任务交替运行并行：多个任务同时运行 如果只有一个CPU，系统是不可能并行执行任务，只能并发。因为CPU每次只能执行一条指令。 原子性 原子性：指不可分割的操作。 12int a = 1;a++; 可以看出第一个语句是原子操作，而第二个语句包含读取、加、赋值三个操作，故不是原子操作。 Java内存模型中定义了八种原子操作。 操作 作用处 说明 lock（锁定） 主内存变量 把一个变量标识成一条线程独占的状态 unlock（解锁） 主内存变量 把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 read（读取） 主内存变量 把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用 load（载入） 工作内存变量 把 read 操作得到的变量放入到工作内存的变量副本中 use（使用） 工作内存变量 将工作内存中的一个变量的值传递给执行引擎 assign（赋值） 工作内存变量 将执行引擎接收到的值赋给工作内存的变量 store（存储） 工作内存变量 把工作内存中一个变量的值传给主内存中，以便给随后的 write 操作使用 write（写入） 主内存变量 把 store 操作从工作内存中得到的变量的值放入主内存变量中 在这里补充介绍一下内存模型。 把一个变量从主内存中复制到工作内存中就需要执行read和load操作，将工作内存同步到主内存中就需要执行store和write操作。注意的是，java内存模型只是要求上述两个操作是顺序执行的，而并不是连续执行的。也就是说read和load之间、store和write之间可以插入其他指令。比如对主内存中的a,b进行访问可以出现这样的操作顺序：read a, read b, load b, load a。 可见性 可见性：指一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 在开发过程中，一定要多关注可见性。如果一个线程在修改共享变量，而其他线程并不知道这个修改，就会出现一些意料之外的逻辑错误。 有序性 有序性： 指程序的运行顺序和编写代码的顺序一致。 编译器和处理器会对不具有数据依赖性的操作进行重排序，来提升运行速度。 而数据依赖性只会在单线程中出现。所以，仅观察单一线程，所有操作都是有序的，但多个线程之间的操作，很可能被重排序了。 这个特性也需要我们在处理多线程问题时多加关注。 线程安全掌握上面的多线程知识，再来理解线程安全就非常容易了。这里我们用经典的多窗口案例来讲。 产生案例假设一共有10张票，现在一共有两个窗口在卖。这里票就是共享变量，而窗口就是线程。我们可以很容易地写出下面的代码。 123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity &#123; private int ticketNum = 30; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void sell(View view) &#123; SellThread sellThread1 = new SellThread(&quot;窗口A&quot;); SellThread sellThread2 = new SellThread(&quot;窗口B&quot;); sellThread1.start(); sellThread2.start(); &#125; class SellThread extends Thread &#123; public SellThread(String name) &#123; super(name); &#125; @Override public void run() &#123; super.run(); while (true) &#123; if (ticketNum &lt;= 0) &#123; break; &#125; Log.d(&quot;Chen&quot;, getName() + &quot; 卖出第 &quot; + ticketNum + &quot; 张票，剩余的票数：&quot; + --ticketNum); &#125; &#125; &#125;&#125; 我们启动两个线程不停循环卖票，每次卖出一张，总票数就减少一张。如果总票数为0，就停止循环。运行结果如下（实际每次运行结果会不一样）。 12345678910111213141516171819202122232425262728293003-31 09:51:42.669 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 30 张票，剩余的票数：2903-31 09:51:42.669 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 29 张票，剩余的票数：2803-31 09:51:42.669 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 28 张票，剩余的票数：2703-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 27 张票，剩余的票数：2603-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 26 张票，剩余的票数：2503-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 25 张票，剩余的票数：2403-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 24 张票，剩余的票数：2303-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 24 张票，剩余的票数：2203-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 22 张票，剩余的票数：2103-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 21 张票，剩余的票数：2003-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 20 张票，剩余的票数：1903-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 20 张票，剩余的票数：1803-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 18 张票，剩余的票数：1703-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 17 张票，剩余的票数：1603-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 16 张票，剩余的票数：1503-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 15 张票，剩余的票数：1403-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 14 张票，剩余的票数：1303-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 13 张票，剩余的票数：1203-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 12 张票，剩余的票数：1103-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 11 张票，剩余的票数：1003-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 10 张票，剩余的票数：903-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 9 张票，剩余的票数：803-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 8 张票，剩余的票数：703-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 7 张票，剩余的票数：603-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 6 张票，剩余的票数：503-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 5 张票，剩余的票数：403-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 4 张票，剩余的票数：303-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 3 张票，剩余的票数：203-31 09:51:42.670 19836-20275/com.chen.study D/Chen: 窗口B 卖出第 2 张票，剩余的票数：103-31 09:51:42.670 19836-20274/com.chen.study D/Chen: 窗口A 卖出第 1 张票，剩余的票数：0 可是我们看到，窗口A和窗口B同时都卖出了第24张和第20张票，这并不符合实际情况。而这个产生的原因就是线程不安全。 解决方案我们可以用synchronized代码块来解决这个线程不安全的问题。 修改上面代码的run()方法，添加synchronized包裹代码块。 1234567891011public void run() &#123; super.run(); while (true) &#123; synchronized (this) &#123; if (ticketNum &lt;= 0) &#123; break; &#125; Log.d(&quot;Chen&quot;, getName() + &quot; 卖出第 &quot; + ticketNum + &quot; 张票，剩余的票数：&quot; + --ticketNum); &#125; &#125;&#125; 运行结果如下，这次就跟我们预期一样了。 12345678910111213141516171819202122232425262728293003-31 10:05:27.282 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 30 张票，剩余的票数：2903-31 10:05:27.283 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 29 张票，剩余的票数：2803-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 28 张票，剩余的票数：2703-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 27 张票，剩余的票数：2603-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 26 张票，剩余的票数：2503-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 25 张票，剩余的票数：2403-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 24 张票，剩余的票数：2303-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 23 张票，剩余的票数：2203-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 22 张票，剩余的票数：2103-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 21 张票，剩余的票数：2003-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 20 张票，剩余的票数：1903-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 19 张票，剩余的票数：1803-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 18 张票，剩余的票数：1703-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 17 张票，剩余的票数：1603-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 16 张票，剩余的票数：1503-31 10:05:27.284 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 15 张票，剩余的票数：1403-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 14 张票，剩余的票数：1303-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 13 张票，剩余的票数：1203-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 12 张票，剩余的票数：1103-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 11 张票，剩余的票数：1003-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 10 张票，剩余的票数：903-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 9 张票，剩余的票数：803-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 8 张票，剩余的票数：703-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 7 张票，剩余的票数：603-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 6 张票，剩余的票数：503-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 5 张票，剩余的票数：403-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 4 张票，剩余的票数：303-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 3 张票，剩余的票数：203-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 2 张票，剩余的票数：103-31 10:05:27.285 29787-32670/com.chen.study D/Chen: 窗口A 卖出第 1 张票，剩余的票数：0 总结好了，关于多线程的一些相关概念知识就梳理到这了。相信会对我们在多线程编程时遇到的一些诡异问题的解决有所帮助。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Android中的线程池]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%B0%88%E8%B0%88Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[从概念到实现，再从应用到原理。关于线程池，你所应该知道的一切。 线程池简介在操作系统中，线程时操作系统调度的最小单元。同时线程又是一种受限的系统资源，什么意思呢？就是说线程不可能无限制的产生，并且线程的创建和销毁的过程都会产生相应的开销。 当系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程。因此线程不可能做到绝对的并行，除非线程数小于等于CPU的核心数，一般这是不太可能的。 如果我们在一个进程中，频繁地创建和销毁线程，显然不是一个高效的做法。线程池就是为了解决这一问题，应运而生。 线程池简单来说，就是一个缓存了一定数量线程的区域。 它的优点可以大致归纳为以下三点。 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。 能有效地控制线程的最大并发数，避免大量的线程因为互相抢占资源而导致的阻塞现象。 能够对线程进行简单的管理，并提供定时执行以及指定时间间隔循环执行等功能。 线程池的实现Android中的线程池的概念，来源于Java中的Executor。Executor是一个接口，它的真正实现类是ThreadPoolExecutor，ThreadPoolExecutor的构造方法提供了一系列的参数来配置线程池。 123456public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 接下来，对这些参数逐一做简单的解释。 核心线程数（corePoolSize）默认情况下，核心线程会在线程池中一直存活，即便它们属于闲置状态。 如果我们改变ThreadPoolExecutor的allowCoreThreadTimeOut属性，将其设置为true，那么核心线程在闲置时会有超时策略。当闲置核心线程的等待新任务时间超过某个时长后，核心线程就会被终止。这个时长由keepAliveTime指定。 最大线程数（maximumPoolSize）当线程池的活动线程数达到最大线程数后，后续新的任务将会被阻塞。 超时时长（keepAliveTime）非核心线程如果闲置时长超过这个超时时长，非核心线程就会被回收。 上面提到过，如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，核心线程同样也会被这个超时时长支配。 时间单位（unit）这是超时时长参数的时间单位，为一个枚举。常见的有TimeUnit.MILLISECONDS、TimeUnit.SECONDS、TimeUnit.MINUTES等。 任务队列（workQueue）通过线程池的execute方法提交的Runnable对象会储存在任务队列这个参数中。 线程工厂（threadFactory）线程工厂为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个实现方法：Thread newThread(Runnable r)。 线程池的运行ThreadPoolExecutor在执行任务时会大致遵循以下的规则。 如果线程池中的线程数量没有达到核心线程的数量，会直接创建一个核心线程来执行任务。 如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。 如果任务队列已满，将无法再继续插入。这时如果线程数量如果没有达到线程池规定的最大值，则立刻启动一个非核心线程来执行任务。 如果任务队列已满，而且线程数量已达到线程池规定的最大值，那么就拒绝执行此任务。ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。 线程池的使用线程池的用法如下。 创建线程池创建时，通过配置线程池的参数，从而实现自己所需内存。下面以AsyncTask中的线程池为例。 123456789101112131415161718192021private static final int CPU_COUNT = Runtime.getRuntime().availableProcess();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread(Runnable r) &#123; return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); &#125;&#125;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt; (128);public static final Executor threadPool = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 我们可以很明显的看出线程池的配置规格。 核心线程数为 CPU核心数+1。 最大线程数为 CPU核心数的2倍+1。 超时时长为 1秒。 任务队列的容量为 128。 提交任务通过execute()方法，传入Runnable对象，向线程池提交任务。 1234567threadPool.execute(new Runnable() &#123; @Override public void run() &#123; // 线程执行任务 ... &#125;&#125;); 关闭线程池12threadPool.shutdown();//threadPool.shutdownNow() 此时，会遍历线程池中的所有工作线程，然后逐个调用线程的interrupt()方法中断线程。 shutdown(): 设置线程池的状态为SHUTDOWN，然后中断所有没有正在执行任务的线程。 shutdownNow(): 设置线程池的状态为STOP，然后中断所有没有正在执行任务或暂停任务的线程。并返回等待任务的列表。 一般多以shutdown()关闭线程池。如果任务不一定要执行完，则以shutdownNow()关闭线程池。 常见线程池Android中有四种最常见的线程池，它们都是通过配置好核心参数，来实现自己的功能特性。 定长线程池定长线程池通过Executors.newFixedThreadPool()创建。 它的特性如下。 线程数量固定。 只有核心线程且无超时机制（不会被回收）。 任务队列无大小限制。 123456789101112131415// 创建定长线程池并设置核心线程数量为5ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);// 创建好需执行的线程对象Runnable task =new Runnable() &#123; public void run() &#123; System.out.println(&quot;run run run!&quot;); &#125;&#125;; // 提交任务fixedThreadPool.execute(task); // 关闭线程池fixedThreadPool.shutdown(); 它的特性意味着它能够更快速的响应外界的请求。我们可以通过它控制线程的最大并发数。 可缓存线程池可缓存线程池通过Executors.newCachedThreadPool()创建。 它的特性如下。 只有非核心线程。 非核心线程数量无限制。 超时时长为60秒。 123456789101112131415// 创建可缓存线程池ExecutorService cachedThreadPool = Executors.newCachedThreadPool();// 创建好需执行的线程对象Runnable task =new Runnable() &#123; public void run() &#123; System.out.println(&quot;run run run!&quot;); &#125;&#125;; // 提交任务cachedThreadPool.execute(task); // 关闭线程池fixedThreadPool.shutdown(); 它的特性意味着任何任务到来都会立刻执行，不需要等待。比较适合执行大量的耗时少的任务。 定时线程池定时线程池通过Executors.newScheduledThreadPool()创建。 它的特性如下。 核心线程数量固定。 非核心线程数量无限制。 超时时长为0，非核心线程闲置马上回收。 12345678910111213141516171819// 创建定时线程池并设置核心线程数量为5ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);// 创建好需执行的线程对象Runnable task =new Runnable() &#123; public void run() &#123; System.out.println(&quot;run run run!&quot;); &#125;&#125;; // 提交任务// 延迟1s后执行scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS); // 延迟1000ms后每隔3000ms执行scheduledThreadPool.scheduleAtFixedRate(task, 1000, 3000, TimeUnit.MILLISECONDS); // 关闭线程池scheduledThreadPool.shutdown(); 它主要用于执行定时任务和具有固定周期的任务。 单线程化线程池单线程化线程池通过Executors.newSingleThreadExecutor()创建。 它的特性如下。 只有一个核心线程。 确保所有任务都在一个线程中按顺序执行。 123456789101112131415// 创建单线程化线程池ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();// 创建好需执行的线程对象Runnable task =new Runnable() &#123; public void run() &#123; System.out.println(&quot;run run run!&quot;); &#125;&#125;; // 提交任务singleThreadExecutor.execute(task); // 关闭线程池singleThreadExecutor.shutdown(); 它能够统一所有的外界任务到一个线程中，使这些任务之间不需要处理线程同步的问题。 总结好了，认真读完本文后，你已经对线程池的概念和用法了如指掌。接下来，就是根据项目需求，灵活地运用它们吧！]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键退出App方法合集]]></title>
    <url>%2F2018%2F03%2F14%2F%E4%B8%80%E9%94%AE%E9%80%80%E5%87%BAApp%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一键退出App相信是很多Android开发者都需要去实现的需求，但到底该如何干净利索地实现它呢？来吧，撸一个试试。 首先需要明确的一点是，完全退出App本质来讲分为两个部分。 关闭该App所有的Activity。 结束该App的进程。 接下来我们就分别实现这两个部分。 关闭所有Activity第一步，我们需要关闭所有的Activity。 1.Activity启动模式在Activity启动模式详解中，我们详细讲解了Activity的启动模式，还不熟悉的小伙伴可以先看一下这篇文章。 首先我们把App的入口Activity采用SingleTask启动模式，或者加上标记Intent.FLAG_ACTIVITY_CLEAR_TOP。 当需要退出App时，直接启动App入口的Activity。因为该Acitivity是SingleTask模式，所以系统会帮助我们将该Activity上面的其他Activity全部关闭移除，并把该Activity放置在栈顶。 123456@Overrideprivate void exitApp() &#123; Intent intent = new Intent(context, MainActivity.class); intent.putExtra(&quot;exitApp&quot;, true); context.startActivity(intent);&#125; 接着系统会调用该Activity的onNewIntent()方法，所以我们再在这个方法里判断是否有退出App的标识，如果有则关闭自身。 123456789101112@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); if (intent != null) &#123; // 判断是否退出App的标识 boolean isExitApp = intent.getBooleanExtra(&quot;exitApp&quot;, false); if (isExitApp) &#123; // 关闭自身 this.finish(); &#125; &#125;&#125; 这种方法使用简单便捷。但是必须要规定App入口的Activity采用SingleTask模式，而且如果App里有多任务栈（SingleInstance模式启动），就无能为力了。 2.系统任务栈我们可以同过ActivityManager获取当前系统的任务栈，然后把栈内的所有Activity逐个关闭。 123456789101112@TargetApi(Build.VERSION_CODES.LOLLIPOP)// 1. 获取ActivityManagerActivityManager activityManager = (ActivityManager) context.getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);// 2. 获取任务栈List&lt;ActivityManager.AppTask&gt; appTaskList = activityManager.getAppTasks();// 3. 逐个关闭Activityfor (ActivityManager.AppTask appTask : appTaskList) &#123; appTask.finishAndRemoveTask();&#125; 这种方法使用简单便捷。但是只能在Android 5.0以上使用，而且同样，对多任务栈（SingleInstance模式启动）无能为力。 3.BroadcastReceiver我们也可以通过广播监听的方式来实现关闭所有Activity。 首先自定义一个广播接收器，专门用来关闭Activity。 123456789101112public class ExitAppReceiver extends BroadcastReceiver &#123; private Activity activity; public ExitAppReceiver(Activity activity)&#123; this.activity = activity; &#125; @Override public void onReceive(Context context, Intent intent) &#123; activity.finish(); &#125;&#125; 然后在每个Activity里注册广播接收器，这里也可以用一个BaseActivity来实现。 12345678910111213141516public class BaseActivity extends Activity &#123;private ExitAppReceiver mExitAppReceiver；// 在onCreate（）中注册广播接收器protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mExitAppReceiver = new ExitAppReceiver(this); registerReceiver(mExitAppReceiver,new IntentFilter(&quot;com.chen.exit&quot;));&#125;// 在onDestroy（）中注销广播接收器protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(mExitAppReceive);&#125; 最后在需要退出App时，发送广播。 1context.sendBroadcast(new Intent(&quot;com.chen.exit&quot;)); 这里需要注意的是，该方法只能实现用户角度上的一键退出。即只能退出所有Activity，但无法再接着下面的退出整个App进程的操作。因为发送广播后，并不能保证在第一时间接收到广播，所以不能直接在发送后关闭整个进程。 这种方法可以实现多任务栈情况下的一键退出，但需要在每个Activity里注册广播接收器。最关键的是，它无法做到最终终止App进程。 4.重写Application我们可以在Manifest里配置自定义的Application子类。 1234&lt;application ... android:name=&quot;.MyApplication&quot;&lt;/application&gt; 接着在MyApplication里建立一个Activity的链表结构，来保存正在运行的Activity实例。当需要一键退出时，把链表里的所有Activity实例逐个退出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MyApplicaiton extends Application &#123; // 采用LinkedList，增删速度快 public static LinkedList&lt;Activity&gt; activityLinkedList; @Override public void onCreate() &#123; super.onCreate(); activityLinkedList = new LinkedList&lt;&gt;(); registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; // 在Activity onCreate()时，保存Activity实例到链表 activityLinkedList.add(activity); &#125; @Override public void onActivityDestroyed(Activity activity) &#123; // 在Activity onDestroyed()时，移除Activity实例 activityLinkedList.remove(activity); &#125; @Override public void onActivityStarted(Activity activity) &#123; &#125; @Override public void onActivityResumed(Activity activity) &#123; &#125; @Override public void onActivityPaused(Activity activity) &#123; &#125; @Override public void onActivityStopped(Activity activity) &#123; &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; &#125;); &#125; public void exitApp() &#123; // 逐个退出Activity for (Activity activity : activityLinkedList) &#123; activity.finish(); &#125; &#125;&#125; 接着调用一键退出方法。 1234private MyApplicaiton app;app = (MyApplicaiton) getApplication();app.exitApp(); 该方法同样可以实现多任务栈情况下的一键退出，但它需要Activity经历正常的生命周期，即创建时调用onCreate()，结束时调用onDestroy()。 5.EventBus或者RxBus我们也可以借助EventBus或者RxBus来实现这个功能，这里以RxBus为例。 首先，在每个Activity的onCreate()方法里注册RxBus，并判断响应动作是否为退出App，如果是则关闭自己。这里要记得要在onDestroy()方法里取消订阅。 1234567891011121314151617181920212223242526public class BaseActivity extends Activity &#123; private Disposable disposable; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 注册RxBus disposable = RxBus.getInstance().toObservable(String.class) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; // 判断响应动作 if (s.equals(&quot;exitApp&quot;))&#123; finish(); &#125; &#125; &#125;); &#125;// 取消订阅 @Overrideprotected void onDestroy() &#123; if (!disposable.isDisposed())&#123; disposable.dispose();; &#125;&#125; 接着在需要退出App时，发送退出事件。 1RxBus.getInstance().post(&quot;exitApp&quot;); 如果项目里已经接入有EventBus或RxBus，可以用该方法简单便捷地实现这个功能。当然，如果项目里没有接入，不建议为该功能特地接入。 结束App进程上面介绍的方法仅仅是用户层面的一键退出，我们应该在所有Activity关闭后，紧接着再结束整个App的进程，实现真正的一键退出。 当然，上面说到了，如果使用BroadcastReceiver方法来关闭所有Activity，就无法再加接下来这一步了。 这里实现方法有两种，不过都非常简单,选择其中任意一种即可。 12345//1.killProcess()android.os.Process.killProcess(android.os.Process.myPid()) ；//2.System.exit()System.exit(0); 这里你可能有个疑问，既然这里可以直接关闭App进程，那为什么还要第一步关闭所有Activity呢？ 那我们就做一个实验，先逐个启动ActivityA，ActivityB和ActivityC，接着在ActivityC里调用结束App进程的方法。 我们会发现进程先结束了，接着又重新开启，启动ActivityA和ActivityB。 因为Android中的ActivityManager会时刻监听着进程，如果发现进程被非正常结束，它会去尝试重启这个进程。 总结至此，一键退出App的所有方法你都应该掌握啦。在项目里根据实际情况，选择最适合的那一种吧。]]></content>
      <categories>
        <category>Android 实战</category>
      </categories>
      <tags>
        <tag>退出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式详解]]></title>
    <url>%2F2018%2F03%2F11%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们可以通过指定Activity的启动模式，来选择任务栈的具体管理规则。 任务栈关于栈结构，相信大家都不陌生，它是一个后进先出（Last In First Out）的线性表。 而一个Android应用程序功能通常会被拆分成多个Activity，它们之间通过Intent进行连接。Android系统就是通过栈结构来保存应用程序的Activity，栈底的元素是整个任务栈的发起者。一个合理的任务栈是性能的保证和基础。 当一个App启动时，如果当前环境中不存在该App的任务栈，那么系统就会创建一个任务栈。默认情况下，该App所启动的所有Activity都将在这个任务栈中被管理。这个栈也被称为一个Task，也表示为若干个Activity的集合。需要注意的是，一个Task中的Activity可以来自不同的App，同一个App的Activity也可以不在同一个Task中。 Mainifest启动模式Mainifest文件中一共提供了四种启动模式： 标准模式（Standard） 栈顶复用模式（SingleTop） 栈内复用模式（SingleTask） 单例模式（SingleInstance） 它们可以在AndroidMainifest中进行设置。 123456789&lt;activity android:launchMode=&quot;启动模式&quot; //属性 //standard：标准模式 //singleTop：栈顶复用模式 //singleTask：栈内复用模式 //singleInstance：单例模式 //如不设置，Activity的启动模式默认为标准模式（standard）&lt;/activity&gt; 这四种功能都具有不同的功能，接下来一一地来进行介绍。 标准模式（Standard）Standard是默认的启动模式，如果不指定Activity的启动模式，则使用这种方式启动Activity。 该模式下一个ActivityA启动了另一个ActivityB时，新启动的ActivityB就会置于任务栈的顶端，并处于活动状态，而ActivityA仍然保留在任务栈中，当用户按下返回键或者调用finish()方法时，系统会移除顶部的ActivityB，让后面的ActivityA恢复活动状态。 每次启动Activity，都会创建新的实例，覆盖在原Activity上。如下图所示。 栈顶复用模式（SingleTop）有些情况下，你可能会觉得Standard模式不够合理。有时候Activity明明在最前面了，还是会继续创建多个Activity，这时候你就需要用到SingleTop模式了。 该模式下在启动Activity时，系统会判断当前栈顶的Activity是不是要启动的Activity。如果不是则创建新的Activity；如果是则不会创建，而是直接引用这个Activity。 这种启动模式虽然不会创建新的Activity，但仍会在启动时调用onNewIntent()方法。 栈内复用模式（SingleTask）SingleTask模式可以保证让某个活动在整个应用程序的上下文中只存在一个实例。 该模式会检测整个栈是否存在当前需要启动的Activity。如果不存在正常创建Activity；如果已存在，则将该Activity置于栈顶，并将该Activity以上的其他Activity都销毁。 如果其他程序以SingleTask模式启动这个Activity，那么它将创建一个新的任务栈。需要注意的是，如果这个Activity已经在后台的一个任务栈中了，那么启动后，后台的这个任务栈将会整个被切换到前台。借助官网的一张图可以很容易地理解这一情况。 当Activity2以SingleTask模式启动ActivityY时，ActivityY所在任务栈会被整个切换到前台。所以这时按下返回键，会回到ActivityX，而不是Activity1。 依据这个特性，我们可以使用该启动模式来一键关闭当前App的所有activity，具体可以参考一键退出App方法合集。 单例模式（SingleInstance）SingleInstance模式可以保证Activity所在的任务中始终只会有一个Activity，通过这个Activity再打开的其它Activity也会被放入到别的任务当中。系统不会向声明成SingleInstance模式的Activity所在的任务当中再添加其它Activity。 假如我们的App中有一个Activity是允许其他App调用的，而且其他App可以与我们的App共享这个Activity的实例，我们就可以采用这种模式。因为SingleInstance模式会有一个单独的返回栈来管理这个Activity。 如果我们用ActivityA打开了ActivityB，而ActivityB是SingleInstance模式，紧接着再用Activity启动ActivityC。此时按下返回键，会发现回直接从ActivityC返回到了ActivityA。具体如下图所示。 Intent Flag启动模式我们不仅可以在AndroidMainifest中设置Activity启动模式，也可以通过activity.addFlag()的模式进行设置 12activity.addFlag(Intent.FLAG_ACTIVITY_SINGLE_TOP);activity.addFlag(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FlAG_ACTIVITY_NEW_TASK); FlAG_ACTIVITY_NEW_TASK该模式使用一个新的TASK来启动一个Activity，但启动的每个Activity都将在一个新的TASK中。 由于Service中并不存在Activity栈，所以这种模式非常适用于在Service中启动Activity。创建一个新的Activity栈并创建新的Activity实例。 Intent.FLAG_ACTIVITY_SINGLE_TOP与上面的SingleTop模式相同。 FLAG_ACTIVITY_CLEAR_TOP与上面的SingleTask模式相同。 FLAG_ACTIVITY_NO_HISTORY该模式启动Activity，当该Activity启动其他Acitivity后，该Activity就消失了，不会存在于Activity栈中。 比如分别启动ActivityA、ActivityB和ActivityC，其中ActivityB设置了Intent.FLAG_ACTIVITY_NO_HISTORY模式，最终的任务栈中为ActivityA和ActivityC。 清空任务栈如果用户将任务栈切换到后台之后过了很长一段时间，系统会将这个任务栈除了最底下的Activity之外的其他所有Activity都清除。 用户重新切换这个任务栈回前台，将只能看到最底下的那个Activity。 当然，必要的时候，我们也可以在AndroidMainifest中通过设置相关的属性，来改变系统的这种默认行为。 12345&lt;activity android:alwaysRetainTaskState=&quot;true&quot; //android:clearTaskOnLaunch=&quot;true&quot; //android:finishOnTaskLaunch=&quot;true&quot;&lt;/activity&gt; alwaysRetainTaskState如果将最底层的那个Activity的这个属性设置为true，那么上面所描述的默认行为就将不会发生。 任务中所有的Activity即使过了很长一段时间之后仍然会被继续保留。 clearTaskOnLaunch如果将最底层的那个Activity的这个属性设置为true，那么只要用户离开了当前任务，再次返回的时候就会将最底层Activity之上的所有其它Activity全部清除掉。 简单来讲，这就是一种和alwaysRetainTaskState完全相反的工作模式，也是默认模式的增强版。 它保证每次返回任务的时候都会是一种初始化状态，即使用户仅仅离开了很短的一段时间。 finishOnTaskLaunch与前两个模式不同，这个属性不是作用于整个任务上的，而是作用于单个Activity上。 如果某个Activity将这个属性设置成true，那么用户一旦离开了当前任务，再次返回时这个Activity就会被清除掉。 总结学习了这么全面的启动模式的知识，相信你一定对Activity任务栈的管理十分的得心应手了。 需要明确的一点是，我们使用启动模式和清理方法，是为了让程序的运行更有效率，有更好的用户体验。 所以使用时一定要根据需求谨慎使用，不能过度滥用，从而导致整个App的栈管理混乱。]]></content>
      <categories>
        <category>Android 基础</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的回调机制]]></title>
    <url>%2F2018%2F03%2F11%2FAndroid%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[回调就是A类中调用B类的方法b，然后B类中反过来调用A类的方法a。a这个方法就是回调方法。 概念分析直接看回调概念，可能会是一头雾水，这个绕口令在说啥。那么就用一个现实生活中的场景，来模拟一下回调。 有一天，老板有一个活，需要员工来完成。老板很忙，有很多其他事，不能等着员工一直到这个活干完。于是他告诉员工，干完这个活后，就去办公室通知他。过了一天，员工打电话告诉老板，活干完了。通知老板这个行为就是一种回调。 实际意义那么，为什么要用到回调呢？首先，编码过程中可能会出现像上面安排活一样的异步耗时需求。其次，回调增强了代码的可扩展性。 比如我们在使用框架的时候，直接调用框架提供的API就可以了。但如果我们想让框架来调用自己写的类中方法，该如何实现呢？难道要去改框架中的代码吗？所以，优秀的框架都会提供好相关的回调接口。我们只需要实现相关的接口，即可完成注册，让框架在合适的时候调用我们自己写的类。 可以反回头再读一下回调的定义：A类中调用B类的方法b，然后B类中反过来调用A类的方法a。这里我们写的类就是A,框架就是B。这样，不用去修改框架B，只去改自己的类A,就可以个性化定制框架所调用的方法，增强框架的代码扩展性。 代码实现下面，以老板让员工干活，员工干完通知老板为例，用代码实现这一需求。 回调接口首先，定义一个回调接口，里面定义一个回调函数。 12345//回调接口，老板要实现此接口public interface CallBack &#123; //提供联系方法（办公室地址），用来接收员工的汇报 public void receive();&#125; 老板类然后创建回调对象，即老板类。因为员工干完活要通知老板，所以老板要实现回调接口，提供联系方法，接收员工的汇报。 1234567891011121314151617//老板类，实现回调接口public class Boss implements CallBack &#123; //员工对象的引用 private Employee employee; public Boss(Employee employee) &#123; this.employee = employee; &#125; //分配活给员工 public void assign() &#123; employee.setCallBack(Boss.this); employee.work(); &#125; @Override public void receive() &#123; System.out.println("我知道这个活已经做完了"); &#125;&#125; 员工类接着创建控制对象，即员工类。他必须要知道老板的地址（持有回调接口），才能跟老板进行汇报。 1234567891011121314151617//员工类public class Employee &#123; public CallBack callBack = null; //进行注册，获取老板的联系方式 public void setCallBack(CallBack callBack) &#123; this.callBack = callBack; &#125; //员工干活 public void work() &#123; //1.开始干活 for (int i=0;i&lt;10;i++) &#123; System.out.println("事情的第"+i+"步干完了"); &#125; //2.通知老板 callBack.receive(); &#125;&#125; 测试类最后创建测试类。 1234567public class Client &#123; public void test() &#123; Employee employee = new Employee(); Boss boss = new Boss(employee); boss.assign(); &#125;&#125; 步骤总结 定义一个回调接口CallBack。 创建一个回调对象Class A，实现回调接口CallBack。 创建一个控制对象Class B，含有一个参数为CallBack的方法。 回调对象Class A中包含一个控制对象Class B的引用。 Class A调用Class B的方法b。 Class B就可以在b方法中调用Class A的方法a。 Android实例Android中View的点击事件就用到了回调机制。下面就用这个Andriod中最常见的代码做一下简单分析。 首先是有一个回调接口OnClickListener。 123456//这个是View的一个回调接口 //Interface definition for a callback to be invoked when a view is clicked. public interface OnClickListener &#123; //Called when a view has been clicked. void onClick(View v); &#125; 然后是有一个控制对象View，包含一个参数为OnClickListener的方法setOnClickListener。 12345678910111213141516171819public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource &#123; protected OnClickListener mOnClickListener; public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; mOnClickListener = l; &#125; public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); //B类调用A类的方法onClick()，这个onClick()就是回调方法 mOnClickListener.onClick(this); return true; &#125; return false; &#125; &#125; 接着是在回调对象MainActivity中实现回调接口OnClickListener，包含控制对象View的引用button，并调用控制对象View的方法setOnClickListener。 123456789101112131415public class MainActivity extends Activity implements OnClickListener&#123; private Button button; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button1); button.setOnClickListener(this); &#125; //用户点击Button时调用的回调函数，可以个性化定义 @Override public void onClick(View v) &#123; Toast.makeText(getApplication(), "点击了", Toast.LENGTH_LONG).show(); &#125; &#125; 可以对比上面总结出来的步骤，感受Android的点击事件是如何一步一步实现回调的。]]></content>
      <categories>
        <category>Android 基础</category>
      </categories>
      <tags>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 数据加密]]></title>
    <url>%2F2018%2F03%2F11%2FAndroid-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[在Android开发中，客户端与服务器进行数据交互时，无可避免的会涉及到诸如用户信息、密码等敏感信息。因此，对重要数据的加密就显得非常重要。 常用加密方式MD5MD5是一种被广泛使用的密码散列函数。可以将不定长度的信息，加密成固定长度的散列值（128位，一般表示为32位十六进制数字）。 MD5是不可逆的加密算法，常用于只需加密无需解密的数据上，比如用户密码。也常用来保证数据的完整性，因为数据更改后，其加密的MD5也会随着改变，对比前后的MD5值可确定数据是否完整或被更改。 MD5已经被证实无法防止碰撞，可以被加以破解。可以通过多次加密、加盐的方式增大破解难度。但对于高度安全性的数据，一般建议改用其他算法，比如SHA-2、SHA-3。因其稳定快速的特点，MD5仍广泛应用于普通数据的错误检查领域。 RSARSA加密算法是以算法的三位发明者名字首字母命名，是一种非对称加密算法。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。 非对称加密算法：该算法需要两个密钥，公钥和私钥。公钥和私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；反之，如果用私钥对数据进行加密，只有用对应的公钥才能加密。简单来说，即“公钥加密，私钥解密；私钥加密，公钥解密”。 AESAES全称为Advanced Encryption Standard，即高级加密标准，是一种区块加密标准。这个算法已经替代原来的DES（Data Encryption Standard），被多方分析并广为使用。 区块加密是一种对称加密算法。这类算法在加密和解密时使用相同的密钥。 加密使用使用RSA首先，需要生成一对公钥和私钥，生成方法很多，可以网上搜索，下面给出一种示例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//生成密钥对 private KeyPair generateKeyPair() throws Exception &#123; try &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA", new org.bouncycastle.jce.provider.BouncyCastleProvider()); // 这个值关系到块加密的大小，可以更改，但是不要太大，否则效率会低 final int KEY_SIZE = 1024; //1024-bit密钥----目前较流行 keyPairGen.initialize(KEY_SIZE, new SecureRandom()); KeyPair keyPair = keyPairGen.genKeyPair(); return keyPair; &#125; catch (Exception e) &#123; throw new Exception(e.getMessage()); &#125;&#125; //生成公钥private RSAPublicKey generateRSAPublicKey(byte[] modulus, byte[] publicExponent) throws Exception &#123; KeyFactory keyFac = null; try &#123; keyFac = KeyFactory.getInstance("RSA", new org.bouncycastle.jce.provider.BouncyCastleProvider()); &#125; catch (NoSuchAlgorithmException ex) &#123; throw new Exception(ex.getMessage()); &#125; RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger( modulus), new BigInteger(publicExponent)); try &#123; return (RSAPublicKey) keyFac.generatePublic(pubKeySpec); &#125; catch (InvalidKeySpecException ex) &#123; throw new Exception(ex.getMessage()); &#125;&#125; //生成私钥private RSAPrivateKey generateRSAPrivateKey(byte[] modulus, byte[] privateExponent) throws Exception &#123; KeyFactory keyFac = null; try &#123; keyFac = KeyFactory.getInstance("RSA", new org.bouncycastle.jce.provider.BouncyCastleProvider()); &#125; catch (NoSuchAlgorithmException ex) &#123; throw new Exception(ex.getMessage()); &#125; RSAPrivateKeySpec priKeySpec = new RSAPrivateKeySpec(new BigInteger( modulus), new BigInteger(privateExponent)); try &#123; return (RSAPrivateKey) keyFac.generatePrivate(priKeySpec); &#125; catch (InvalidKeySpecException ex) &#123; throw new Exception(ex.getMessage()); &#125;&#125; 生成之后，公钥存放在客户端，可以被别人知道，而私钥则要放在服务端，不能泄露。如果公司有人事变动，避免离职人员泄露私钥，可以重新生成密钥。 单独使用RSA加密，只适用于客户端传输给服务器的数据重要，服务器返回的数据不重要的情况。比如传递用户的手机号等个人信息，需要在客户端使用公钥对数据进行加密，传递到服务器后使用私钥进行解密。而服务器返回给客户端的数据，主要是一些状态码以及提示信息，不需要加密，再直接返回即可。 使用RSA+AES然而还有一些情况，是属于客户端传输给服务器的数据重要，服务器返回的数据也重要。比如用户进行登录时，传递的用户名密码需要加密，返回的令牌Token也需要加密。由于公钥是公开的，只使用RSA加密没办法对返回数据进行加密。这时候，就需要再结合AES加密了。 使用这种加密，主要有以下几个步骤（如果返回数据不重要，可以省略6，7步骤）。 客户端随机产生AES密钥。 客户端对要传输的重要数据进行AES加密。 客户端对AES的密钥，使用RSA的公钥加密。 服务端对拿到的AES密钥用RSA的私钥进行解密，拿到AES密钥原文。 服务端对加密后的重要信息进行AES解密，得到原始内容。 对返回数据，使用得到的AES密钥加密，返回给客户端。 客户端用之前随机产生的AES密钥，对返回结果进行解密。 在这种加密方式中，AES的密钥是在传输过程中才随机生成的，而且传输时通过RSA加密，所以无法被获取到，能有效地保障数据的安全。]]></content>
      <categories>
        <category>Android 基础</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM,DVM,ART到底是些什么]]></title>
    <url>%2F2018%2F03%2F11%2FJVM-DVM-ART%E5%88%B0%E5%BA%95%E6%98%AF%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[自从学习Java和Android开始，就会陆续的听到JVM、DVM、ART这些名词，然而它们到底是些什么呢，有什么相同又有什么区别呢？下面就来深入了解一下。 JVM JVM全称是Java Virtual Machine，意为Java虚拟机。其本质是一个能够运行以Java语言编写程序的软件。 Java在编译后会生成类似于汇编语言的Java字节码。但与C语言编译后产生的汇编语言不同的是，汇编语言会直接在硬件上跑，但Java字节码是在JVM上跑。需要由JVM把字节码翻译成机器指令，才能使Java程序跑起来。 JVM远行在操作系统上，屏蔽了底层实现的差异。JRE（Java Runtime Environment，包括JVM、Java核心类库和支持文件）编译时针对每个平台，因此下载JRE时是分平台的。JVM把平台无关的.class里面的字节码翻译成平台相关的机器码。从而实现了Java的跨平台。 DVM DVM全称是Dalvik Virtual Machine（Dalvik是作者的祖先曾经居住过的小渔村名字，位于冰岛），是Android中使用的虚拟机。 所有Android程序都运行在Android系统进程里，每一个进程都对应一个Dalvik虚拟机实例。这样，独立的进程可以防止在虚拟机崩溃时所有程序都被关闭。以下列出DVM和JVM的区别。 运行的字节码不同 Java程序经过编译，生成Java字节码保存在class文件中，JVM通过解码class文件中的内容来运行程序。 而DVM运行的是Dalvik字节码。所有的Dalvik字节码是由dx工具，将Java字节码转换而来，并被打包到dex（Dalvik Executable）可执行文件中，DVM通过解释dex文件来执行Dalvik字节码。 可执行文件体积不同 dx工具会对Java类程序重新排列，把多个类包含在一个dex文件之中。各个类中重复的字符串和其他常数在dex中只存放一次，以节省空间。所以，Dalvik可执行文件体积更小。 JVM基于栈，DVM基于寄存器 JVM基于栈结构，程序在运行时虚拟机需要频繁地从栈上读写数据，这个过程需要更多的指令分派和内存访问次数，会耗费很多CPU时间。 DVM基于寄存器，数据的访问通过寄存器直接传递，要快很多。 两种架构各有优劣。一般而言，基于堆栈的机器需要更多指令，基于寄存器的机器指令更长。 ART ART全称是Android Runtime，在2013年作为Android4.4系统中的一项测试功能正式对外发布，在5.0及后续版本中作为正式的运行时库取代了以往的DVM。 ART与DVM主要不同在于：DVM采用的是JIT技术，而ART采用的是AOT技术。同时ART也改善了性能、垃圾回收、应用程序排错以及性能分析。 JIT全称是Just In Time，意为即时编译技术。AOT全称是Ahead Of Time，意为预编译技术。它们是两种不同的编译模式。 DVM执行的是dex字节码，依靠JIT编译器去解释执行，运行时动态的将执行效率很高的dex字节码翻译成本地机器码,然后再执行。而ART直接执行的是本地机器码，在应用程序安装过程中，ART就已经将所有字节码重新编译成了机器码。 DVM的解码过程发生在应用程序的运行过程中，并且应用程序每次重新运行，都要重复这个解码过程。而ART在应用程序运行过程中无需进行实时的编译工作，只需进行直接调用。因此，即使采用了JIT,DVM的总体性能还是不能与ART相比。 总的来说，ART的优点在于：提高了应用程序的运行效率，减少了手机的电量消耗，提高了移动设备的续航能力，在垃圾回收等机制上也有了较大的提升。而它的缺点在于：ART模式下Android应用程序的安装需要消耗更多的时间，同时也会占用更大的储存空间（大约增加10%~20%）。]]></content>
      <categories>
        <category>Android 基础</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件拦截机制详解]]></title>
    <url>%2F2018%2F03%2F10%2FAndroid%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[当Android系统捕获到用户的触摸事件后，我们该如何准确地找到真正想要处理这个事件的控件呢？对于一些常见的滑动冲突，我们又该如何去解决呢？看完这一篇，你就全明白了。 触摸事件要想了解触摸事件的拦截机制，首先我们必须得清楚什么是触摸事件。很简单，触摸事件就是捕获到用户触摸屏幕的行为后产生的事件。 比如说，当一个按钮被点击时，通常就会产生两至三个事件：按下，（滑动），抬起。Android专门为触摸事件封装了一个类：MontionEvent。如果要重写触摸相关的方法，比如onTouchEvent(), 参数一般都含有MontionEvent类。 在MontionEvent类里，封装了不少有用的东西。比如通过event.getX()以及evnet.getRawX()方法来分别获取触摸点的相对位置和绝对位置；还有通过event.getAction()获取触摸类型（MotionEvent.ACTION_DOWN,MotionEvent.ACTION_MOVE,MotionEvent.ACTION_UP等）。 所以说，触摸事件就是一个简单的动作类型加坐标。但Android的View结构是树状的，可以通过不同的组合来实现不同样式。举一个简单的例子，有一个View，放在一个ViewGroupA里，而这个ViewGroupA放在一个ViewGroupB里，此时触摸这个View，这个事件到底该怎么分呢？所以，就产生了事件拦截这个东西。 事件拦截构建模型事件拦截在身边可以找到一个非常契合且非常贴近生活的例子。比如在你的公司，你是一个普通员工，在你的上面是技术主管，技术主管再往上是总经理。总经理给技术主管安排任务，技术主管再分派给你；你完成任务后，汇报给技术主管，技术主管再汇报给总经理。 在上面的例子里，总经理就是最外层的ViewGroupA，技术主管就是中间的ViewGroupB，你就是最里面的那个View。 我们这里创建对应的布局文件，并重写控件里的方法，来加深我们对事件拦截机制的理解。 对于ViewGroupA，重写如下三个方法。 1234567891011121314151617@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;Chen&quot;, &quot;ViewGroupA dispatchTouchEvent&quot;); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.d(&quot;Chen&quot;, &quot;ViewGroupA onInterceptTouchEvent&quot;); return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.d(&quot;Chen&quot;, &quot;ViewGroupA onTouchEvent&quot;); return super.onTouchEvent(event);&#125; 对于View，重写如下两个方法。 1234567891011@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.d(&quot;Chen&quot;, &quot;View dispatchTouchEvent&quot;); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.d(&quot;Chen&quot;, &quot;View onTouchEvent&quot;); return super.onTouchEvent(event);&#125; 正常情形这里可以看出，ViewGroup的级别比较高，比View多出一个onInterceptTouchEvent()方法。这个名字很容易地让我们猜到是事件拦截地核心方法。我们先不改动任何返回值，先点击一下View，观察Log： D/Chen: ViewGroupA dispatchTouchEventD/Chen: ViewGroupA onInterceptTouchEventD/Chen: ViewGroupB dispatchTouchEventD/Chen: ViewGroupB onInterceptTouchEventD/Chen: View dispatchTouchEventD/Chen: View onTouchEventD/Chen: ViewGroupB onTouchEventD/Chen: ViewGroupA onTouchEvent 所以我们发现，在正常情形下，事件的传递顺序是：总经理（ViewGroupA） –&gt; 技术主管（ViewGroupB） –&gt; 你（View）。事件传递时先执行dispathTouchEvent()方法（View没有该方法），再执行onInterceptTouchEvent()方法。 事件的处理顺序是你（View） –&gt; 技术主管（ViewGroupB） –&gt; 总经理（ViewGroupA）。事件处理时执行的是onTouchEvent()方法。 事件分发拦截事件传递以及处理的返回值非常容易理解，True就是拦截或处理了，不再继续传递；False就是继续传递。初始情况下，返回值都是False。接下来我们就修改下返回值，验证我们的上述说法。通常情况下，我们不太会改动dispathTouchEvent()方法，而是用onInterceptTouchEvent()进行事件拦截。 假设总经理（ViewGroupA）发现任务非常简单，自己举手之劳就能完成，不需要再找手下人来做了，于是他就决定自己来做。我们修改ViewGroupA的onInterceptTouchEvent()方法，使其返回Ture，接下来观察Log： D/Chen: ViewGroupA dispatchTouchEventD/Chen: ViewGroupA onInterceptTouchEventD/Chen: ViewGroupA onTouchEvent 跟设想的一样，总经理拦截了事件，手下人就不需要再做这件事了。 同理，如果总经理照常分发给技术主管，但技术主管拦截了事件，即ViewGroupB的onInterceptTouchEvent()方法返回了True，Log就会变成这样： D/Chen: ViewGroupA dispatchTouchEventD/Chen: ViewGroupA onInterceptTouchEventD/Chen: ViewGroupB dispatchTouchEventD/Chen: ViewGroupB onInterceptTouchEventD/Chen: ViewGroupB onTouchEventD/Chen: ViewGroupA onTouchEvent 可以看到，这次不用干活的仅仅就是你（View）了。 事件处理说完了事件拦截分发，接下就是事件的处理了。在上面的正常情形中，我们可以看到，你（View）完成了工作，需要向技术主管（ViewGroupB）汇报，接着技术主管需要向总经理（ViewGroupA）汇报。 假如你（View）觉得这个工作完成后，没必要再向技术主管（ViewGroupA）汇报了，即在View的onTouchEvnet()方法里返回了True，我们来看一下Log： D/Chen: ViewGroupA dispatchTouchEventD/Chen: ViewGroupA onInterceptTouchEventD/Chen: ViewGroupB dispatchTouchEventD/Chen: ViewGroupB onInterceptTouchEventD/Chen: View dispatchTouchEventD/Chen: View onTouchEvent 可以发现，事件的传递跟正常情形还是一样，但是事件的处理，到了你（View）这里就结束了，因为你没有继续往上进行汇报。 如果你（View）正常向技术主管（ViewGroupB）汇报了，但是技术主管觉得没必要再向总经理（ViewGroupA）进行汇报了，Log就会变成这样： D/Chen: ViewGroupA dispatchTouchEventD/Chen: ViewGroupA onInterceptTouchEventD/Chen: ViewGroupB dispatchTouchEventD/Chen: ViewGroupB onInterceptTouchEventD/Chen: View dispatchTouchEventD/Chen: View onTouchEventD/Chen: ViewGroupB onTouchEvent 这一次，事件分发到了技术主管（ViewGroupB）这里就结束了。 总结通过上面这么接地气的实例，相信你一定对事件的拦截分发以及处理的流程有了一个非常深入的了解了。 虽然这个模型是一个最简单的模型，但只要你真正理解了，就能够举一反三。以后再遇到任何复杂的需求，比如滑动冲突的解决，相必你都可以想到方法去解决~]]></content>
      <categories>
        <category>Android 基础</category>
      </categories>
      <tags>
        <tag>事件拦截</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建Github博客]]></title>
    <url>%2F2018%2F03%2F06%2F%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BAGithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[最近看到不少人在使用Hexo搭建自己的个人博客，很感兴趣。于是找了一些资料，踩了一些坑，也搭建了属于自己的博客。以下为搭建的步骤(Windows环境)。 前期环境准备安装Git直接到Git官方下载地址下载并进行傻瓜式安装即可。 安装Node.js同样，直接到Node.js官方下载地址下载并进行傻瓜式安装即可。 安装Hexo任意位置使用Git bash，利用以下npm命令即可完成安装。 1npm install -g hexo 本地搭建创建文件夹选择你需要安装的文件夹，比如E:\hexo，使用Git bash 执行以下指令，便会自动在该文件夹中导入建立网站所需文件。 1hexo init 安装依赖包接着，还是在E:\hexo的Git bash 中执行以下命令，安装依赖包。 1hexo install 运行本地服务器最后，在E:\hexo的Git bash中执行以下命令，生成网页，启动服务器。 12hexo generatehexo server 现在，本地的网站就已经搭建好了，在浏览器中输入localhost:4000即可查看我们的网站了。 配置Github注册Github账号到Github官网，填写用户名、邮箱、密码即可完成注册。 创建仓库注册完后就可以点击New repository，新建一个仓库。这里要注意，仓库的名称，必须是你的用户名.github.io，比如我的仓库名为：miraclechen001.github.io。 添加SSH密钥首先得明确一点，这一步不是必须的。如果不添加，每次博客有改动提交的时候就需要手动输入账号密码，配置了就不需要了。所以建议可以在常用的个人电脑上添加一下。 SSH公钥默认在C:\Users\Administrator\.ssh目录下，如果没有这个目录，需要手动生成一下。直接到Git的程序目录里，运行git-bash.exe，然后运行以下指令。 1cd ~ 这条指令中的邮箱名填写自己的邮箱，打完指令根据提示连续三个回车，设置密码为空即可。 1ssh-keygen -t rsa -C "miraclechen001@126.com" 注意，ssh与-keygen之间是没有空格的，否则会报 Bad escape character ‘ygen’。 运行完指令后，在C:\Users\Administrator\.ssh目录下找到id_rsa.pub，复制里面所有字符，到Github设置SSH的页面,New SSH key，粘贴进去就添加完毕了。 最终部署全局配置首先，先来了解一下hexo的主要目录结构。 .deploy_git #需要部署的文件 node_modules #hexo插件 public #生成的静态网页 scaffolds #模板 source #源文件（博客正文、404页面等） themes #主题 _config.yml #全局配置文件 这里我们要配置的就是_config.yml文件。需要注意的常用修改如下。 1234567891011title: Miracle Chen #标题subtitle: 拿来长岛冰茶，换我半夜安睡 #副标题description: Chen&apos;s Blog #为搜索引擎提供的站点描述author: Chen #作者language: zh-Hans #语言（中文简体）url: http://zhcng.github.io #自己的链接theme: landscape #主题deploy: type: git repo: https://github.com/miraclechen001/miraclechen001.github.io #自己新建的git仓库地址 branch: master 添加文章首先，运行以下指令新建一篇文章，会在source/_posts目录下生成标题.md。 1hexo new "标题" 打开文件用Markdown语法编辑正文。完成保存后运行以下指令进行本地预览。 1hexo server 这里再次运行部署前，建议先清理缓存，所以上面的命名行可以用下面的代替。 1hexo clean &amp;&amp; hexo s 最后，运行以下指令生成网页，完成部署。 12hexo generatehexo deploy 如果deploy遇到Deployer not found: git问题，运行以下指令，然后重新deploy。 1npm install hexo-deployer-git --save 出现[info] Deploy done: git，表明部署成功。此时打开用户名.github.io就可以看到自己的博客了。 更换主题我们可以为hexo更换各种已有的主题。这里我使用的是Next主题，这也是目前热度最高的主题。下面就这个主题的更换做简单的说明，更详细的教程可以查看这里。 安装主题在E:\hexo文件夹下运行以下指令，下载主题。 1git clone https://github.com/iissnan/hexo-theme-next themes/next 再到E:\hexo下找到配置文件_config.yml，修改theme属性为next。此时重新运行服务器即可预览当前主题。 设置头像默认头像存储路径在E:\hexo\themes\next\source\images，配置是在E:\hexo\themes\next中的_config.yml中的avatar属性。注意这里是主题的配置文件，而不是hexo的配置文件。 设置站点小图标可以跟头像一样，将站点小图标放在E:\hexo\themes\next\source\images。在主题配置文件中修改favicon属性进行对应即可。站点小图标可以在这里进行制作。 设置主菜单在主题的配置文件中找到menu属性，下面列出来的就是主菜单的条目，可以通过在开头加#隐藏掉你不想要的条目。 添加页面需要说明的是，菜单页面的许多页面需要手动添加一下。 使用以下命令，添加tags页面。 1hexo new page "tags" 然后打开E:\hexo\source\tags\index.md文件，加上type: “tags”。 同理，使用以下命令，添加categories页面。 1hexo new page "categories" 然后打开E:\hexo\source\categories\index.md文件，加上type: “categories”。 使用以下命令，新建一个名为about的页面。 1hexo new page "about" 然后在E:\hexo\source\about\index.md文件夹中修改页面内容即可。 显示摘要有两种方法可以使文章在首页显示摘要而不是全文。 一种是在正文中增加&lt;!-- more --&gt;标签，这样标签前的文字就能显示在首页中。 还有一种是在Front-matter中添加description属性，这样就可以在首页中显示属性的内容。 总结好了，到了这里，应该一个有很不错的风格的博客已经搭建起来了。你可以通过用户名.github.io来访问这个网站。并且，只需要你有简单的MarkDown基础，就可以很方便的进行博文的添加与编辑了。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
